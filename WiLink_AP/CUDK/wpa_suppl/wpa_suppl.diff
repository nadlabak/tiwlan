Only in wpa_suppl: aes_wrap.d
Only in wpa_suppl: aes_wrap.o
Only in wpa_suppl: base64.d
Only in wpa_suppl: base64.o
Only in wpa_suppl: bufferObj.c
Only in wpa_suppl: bufferObj.d
Only in wpa_suppl: bufferObj.h
Only in wpa_suppl: bufferObj.o
Only in wpa_supplicant-0.5.7: changelog
Only in wpa_suppl: CipherWrapper.c
Only in wpa_suppl: CipherWrapper.d
Only in wpa_suppl: CipherWrapper.h
Only in wpa_suppl: CipherWrapper.o
Only in wpa_suppl: common.d
Only in wpa_suppl: common.o
Only in wpa_suppl: .config
diff -cr wpa_supplicant-0.5.7/config.c wpa_suppl/config.c
*** wpa_supplicant-0.5.7/config.c	2009-08-16 14:24:55.001499000 +0300
--- wpa_suppl/config.c	2008-11-20 13:16:20.000000000 +0200
***************
*** 22,27 ****
--- 22,34 ----
  #include "l2_packet.h"
  #include "config.h"
  
+ #ifdef CONFIG_EAP_WSC
+ #include "WscTypes.h"
+ #include "ossl_typ.h"
+ #include "rand.h"
+ #include "wsc_supplicant.h"
+ #endif
+ 
  
  /*
   * Structure for network configuration parsing. This data is used to implement
***************
*** 52,72 ****
  	int key_data;
  };
  
- 
  static char * wpa_config_parse_string(const char *value, size_t *len)
  {
! 	if (*value == '"') {
  		char *pos;
! 		value++;
  		pos = os_strrchr(value, '"');
  		if (pos == NULL || pos[1] != '\0')
  			return NULL;
  		*pos = '\0';
  		*len = os_strlen(value);
  		return os_strdup(value);
! 	} else {
  		u8 *str;
  		size_t hlen = os_strlen(value);
  		if (hlen & 1)
  			return NULL;
  		*len = hlen / 2;
--- 59,83 ----
  	int key_data;
  };
  
  static char * wpa_config_parse_string(const char *value, size_t *len)
  {
! 	if (*value == '"') 
! 	{
  		char *pos;
! 			
! 		value++;		
  		pos = os_strrchr(value, '"');
  		if (pos == NULL || pos[1] != '\0')
  			return NULL;
  		*pos = '\0';
  		*len = os_strlen(value);
  		return os_strdup(value);
! 	} 
! 	else 
! 	{
  		u8 *str;
  		size_t hlen = os_strlen(value);
+ 
  		if (hlen & 1)
  			return NULL;
  		*len = hlen / 2;
***************
*** 1030,1035 ****
--- 1041,1160 ----
  	return wpa_config_write_wep_key(ssid, 3);
  }
  
+ #ifdef CONFIG_EAP_WSC
+ static int wpa_config_parse_wsc_pin(const struct parse_data *data, 
+ 					struct wpa_ssid *ssid, int line,
+ 				     const char *value)
+ {
+ 	size_t res_len;
+ 	char c_devPwd[32];
+ 	u32 val;
+ 	u32 checksum;
+ 	u8 devPwd[10];
+ 	u8 password[LONG_PIN_LEN+1];
+ 
+ 	if(!ssid->wsc_pin)
+ 	{
+ 		free(ssid->wsc_pin);
+ 	}
+ 	ssid->wsc_pin = wpa_config_parse_string(value, &res_len);
+ 
+ 	if (ssid->wsc_pin == NULL) 
+ 	{
+ 		wpa_printf(MSG_ERROR, "Line %d: failed to parse %s '%s'.",
+ 			   line, data->name, value);
+ 		return -1;
+ 	}
+ 
+ 	if ((res_len != SHORT_PIN_LEN) && (res_len != LONG_PIN_LEN))
+ 	{
+ 		wpa_printf(MSG_ERROR, "Line %d: failed to parse %s '%s'. Pin length: %d is invalid",
+ 			   line, data->name, value, res_len);
+ 		return -1;
+ 	}
+ 
+ 	if (strncmp(ssid->wsc_pin, RANDOM_PIN_NUMBER, (sizeof(RANDOM_PIN_NUMBER) - 1)) == 0)
+ 	{
+ 		RAND_bytes(devPwd, LONG_PIN_LEN);
+ 		sprintf(c_devPwd, "%08u", *(u32 *)devPwd);
+ 		
+ 		/* Compute the checksum */
+ 		c_devPwd[7] = '\0';
+ 		val = strtoul(c_devPwd, NULL, 10 );
+ 		checksum = wsc_supplicant_ComputeChecksum( val );
+ 		val = val*10 + checksum;
+ 		sprintf((char *)password, "%d", val );
+ 		password[LONG_PIN_LEN] = '\0';
+ 		free(ssid->wsc_pin);
+ 		ssid->wsc_pin = strdup((char *)password);
+ 		
+ 		wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c-%c-%c-%c-%c\n", password[0], password[1], password[2], password[3], password[4], password[5], password[6], password[7]);
+ 	}
+ 	else if (strncmp(ssid->wsc_pin, RANDOM_SHORT_PIN_NUMBER, (sizeof(RANDOM_SHORT_PIN_NUMBER) - 1)) == 0)
+ 	{
+ 		RAND_bytes(devPwd, SHORT_PIN_LEN);
+ 		sprintf(c_devPwd, "%04u", *(u32 *)devPwd);
+ 		c_devPwd[SHORT_PIN_LEN] = '\0';
+ 		
+ 		/* save randomized PIN created */
+ 		strcpy((char *)password, c_devPwd);
+ 		free(ssid->wsc_pin);
+ 		ssid->wsc_pin = strdup((char *)password);
+ 		
+ 		wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c\n", password[0], password[1], password[2], password[3]);
+ 	}
+ 	else 
+ 	{
+ 		wpa_printf(MSG_DEBUG, "PIN exist='%s'", ssid->wsc_pin);
+ 		
+ 		/* (if res_len==4 no checksum check is required) */
+ 		if (res_len == LONG_PIN_LEN)
+ 		{
+ 			/* check the checksum */
+ 			strcpy(c_devPwd, ssid->wsc_pin);
+ 			c_devPwd[7] = '\0';
+ 			val = strtoul(c_devPwd, NULL, 10 );
+ 			checksum = wsc_supplicant_ComputeChecksum( val );
+ 			if (checksum != (ssid->wsc_pin[7] - '0'))
+ 			{
+ 				/* checksum is incorrect */
+ 				wpa_printf(MSG_ERROR, "checksum is incorrect :\nCalculated checksum = %d, wsc_pin[7] = %c, Randomizing new PIN...", checksum, ssid->wsc_pin[7]);
+ 
+ 				/* Randomize new PIN */
+ 				RAND_bytes(devPwd, LONG_PIN_LEN);
+ 				sprintf(c_devPwd, "%08u", *(u32 *)devPwd);
+ 
+ 				/* Compute the checksum */
+ 				c_devPwd[7] = '\0';
+ 				val = strtoul(c_devPwd, NULL, 10 );
+ 				checksum = wsc_supplicant_ComputeChecksum( val );
+ 				val = val*10 + checksum;
+ 				sprintf((char *)password, "%d", val );
+ 				password[LONG_PIN_LEN] = '\0';
+ 				free(ssid->wsc_pin);
+ 				ssid->wsc_pin = strdup((char *)password);
+ 				
+ 				wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c-%c-%c-%c-%c\n", password[0], password[1], password[2], password[3], password[4], password[5], password[6], password[7]);
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static char * wpa_config_write_wsc_pin(const struct parse_data *data,
+ 					struct wpa_ssid *ssid)
+ {
+ 	if (ssid->wsc_pin)
+ 	{
+ 		return wpa_config_write_string_ascii((const u8 *) ssid->wsc_pin, strlen(ssid->wsc_pin));
+ 	}
+ 	return NULL;
+ }
+ 
+ #endif /* CONFIG_EAP_WSC */
+ 
+ 
  
  /* Helper macros for network block parser */
  
***************
*** 1156,1162 ****
  #ifdef CONFIG_IEEE80211W
  	{ INT_RANGE(ieee80211w, 0, 2) },
  #endif /* CONFIG_IEEE80211W */
! 	{ INT_RANGE(peerkey, 0, 1) }
  };
  
  #undef OFFSET
--- 1281,1291 ----
  #ifdef CONFIG_IEEE80211W
  	{ INT_RANGE(ieee80211w, 0, 2) },
  #endif /* CONFIG_IEEE80211W */
! 	{ INT_RANGE(peerkey, 0, 1) },
! #ifdef CONFIG_EAP_WSC
! 	{ FUNC(wsc_pin) },
! 	{ INT(wsc_mode) }
! #endif /* CONFIG_EAP_WSC */
  };
  
  #undef OFFSET
Only in wpa_suppl: config.d
diff -cr wpa_supplicant-0.5.7/config_file.c wpa_suppl/config_file.c
*** wpa_supplicant-0.5.7/config_file.c	2009-08-16 14:24:55.001608000 +0300
--- wpa_suppl/config_file.c	2007-11-07 16:23:27.000000000 +0200
***************
*** 559,564 ****
--- 559,577 ----
  	}
  }
  
+ #ifdef CONFIG_EAP_WSC
+ static void write_wsc_pin(FILE *f, struct wpa_ssid *ssid)
+ {
+ 	char *value;
+ 
+ 	value = wpa_config_get(ssid, "wsc_pin");
+ 	if (value == NULL)
+ 		return;
+ 	if (value[0])
+ 		fprintf(f, "\twsc_pin=%s\n", value);
+ 	free(value);
+ }
+ #endif /* CONFIG_EAP_WSC */
  
  static void wpa_config_write_network(FILE *f, struct wpa_ssid *ssid)
  {
***************
*** 577,582 ****
--- 590,598 ----
  	write_pairwise(f, ssid);
  	write_group(f, ssid);
  	write_auth_alg(f, ssid);
+ #ifdef CONFIG_EAP_WSC
+ 	write_wsc_pin(f, ssid);
+ #endif /* CONFIG_EAP_WSC */
  #ifdef IEEE8021X_EAPOL
  	write_eap(f, ssid);
  	STR(identity);
Only in wpa_suppl: config_file.d
Only in wpa_suppl: config_file.o
Only in wpa_suppl: config.o
diff -cr wpa_supplicant-0.5.7/config_ssid.h wpa_suppl/config_ssid.h
*** wpa_supplicant-0.5.7/config_ssid.h	2009-08-16 14:24:56.000096000 +0300
--- wpa_suppl/config_ssid.h	2009-03-29 12:45:23.000000000 +0300
***************
*** 15,20 ****
--- 15,22 ----
  #ifndef CONFIG_SSID_H
  #define CONFIG_SSID_H
  
+ #include <netinet/if_ether.h>
+ 
  #ifndef BIT
  #define BIT(n) (1 << (n))
  #endif
***************
*** 46,51 ****
--- 48,59 ----
  #define EAP_PSK_LEN_MIN 16
  #define EAP_PSK_LEN_MAX 32
  
+ #ifdef CONFIG_EAP_WSC
+ #define WSC_MODE_OFF	0
+ #define WSC_MODE_PIN	1
+ #define WSC_MODE_PBC	2
+ #endif
+ 
  
  #define DEFAULT_EAP_WORKAROUND ((unsigned int) -1)
  #define DEFAULT_EAPOL_FLAGS (EAPOL_FLAG_REQUIRE_KEY_UNICAST | \
***************
*** 200,205 ****
--- 208,232 ----
  	 */
  	int scan_ssid;
  
+ #ifdef CONFIG_EAP_WSC
+ 	/**
+ 	 * wsc_mode - the WSC mode enum
+ 	 *
+ 	 * this the WSC mode:
+ 	 *	0 - WSC_MODE_OFF
+ 	 * 	1 - WSC_MODE_PIN
+ 	 *	2 - WSC_MODE_PBC
+ 	 */
+ 	u32 wsc_mode;
+ 	/**
+ 	 * wsc_pin -the WSC PIN string
+ 	 *
+ 	 * this the WSC PIN identification string
+ 	 */
+ 	char* wsc_pin;
+ 
+ #endif /* CONFIG_EAP_WSC */
+ 
  #ifdef IEEE8021X_EAPOL
  
  	/**
Only in wpa_supplicant-0.5.7: copying
Only in wpa_suppl: crypto.d
Only in wpa_suppl: crypto.o
diff -cr wpa_supplicant-0.5.7/ctrl_iface.c wpa_suppl/ctrl_iface.c
*** wpa_supplicant-0.5.7/ctrl_iface.c	2009-08-16 14:24:56.000791000 +0300
--- wpa_suppl/ctrl_iface.c	2008-02-20 11:55:42.000000000 +0200
***************
*** 539,549 ****
--- 539,631 ----
  }
  
  
+ #ifdef TI_WLAN_DRIVER
+ static int wpa_supplicant_compare_ssid(struct wpa_ssid *ssid1, struct wpa_ssid *ssid2)
+ {
+    int is_identical = 1,i;
+ 
+    if (ssid1->mode != ssid2->mode)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->ssid_len != ssid2->ssid_len)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->ssid) && (!ssid2->ssid)) || ((!ssid1->ssid) && (ssid2->ssid)) 
+ 	   || (ssid1->ssid && ssid2->ssid && (strcmp((char *)ssid1->ssid,(char *)ssid2->ssid) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->bssid) && (!ssid2->bssid)) || ((!ssid1->bssid) && (ssid2->bssid)) 
+ 	   || (ssid1->bssid && ssid2->bssid && (memcmp((char *)ssid1->bssid,(char *)ssid2->bssid,ETH_ALEN) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->key_mgmt != ssid2->key_mgmt)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->group_cipher != ssid2->group_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->pairwise_cipher != ssid2->pairwise_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->proto != ssid2->proto)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->auth_alg != ssid2->auth_alg)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->wep_tx_keyidx != ssid2->wep_tx_keyidx)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->psk) && (!ssid2->psk)) || ((!ssid1->psk) && (ssid2->psk)) 
+ 	   || (ssid1->psk && ssid2->psk && (strcmp((char *)ssid1->psk,(char *)ssid2->psk) != 0)))
+    {
+          is_identical = 0;
+    }else
+ #ifdef CONFIG_EAP_WSC
+    if (((ssid1->wsc_pin) && (!ssid2->wsc_pin)) || ((!ssid1->wsc_pin) && (ssid2->wsc_pin)) 
+ 	   || (ssid1->wsc_pin && ssid2->wsc_pin && (strcmp((char *)ssid1->wsc_pin,(char *)ssid2->wsc_pin) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->wsc_mode != ssid2->wsc_mode)
+    {
+          is_identical = 0;
+    }else
+ #endif /* CONFIG_EAP_WSC */
+    {
+ 		for (i=0 ; i < NUM_WEP_KEYS; i++)
+ 		{	
+ 			if ((ssid1->wep_key_len[i] != ssid2->wep_key_len[i])
+ 				 || (memcmp(ssid1->wep_key[i], ssid2->wep_key[i], ssid1->wep_key_len[i]) != 0))
+ 			{
+ 				is_identical = 0;
+ 			}
+ 		}
+    }
+ 
+    return (is_identical);
+ }
+ #endif /* TI_WLAN_DRIVER */
+ 
+ 
  static int wpa_supplicant_ctrl_iface_select_network(
  	struct wpa_supplicant *wpa_s, char *cmd)
  {
  	int id;
  	struct wpa_ssid *ssid;
+ #ifdef TI_WLAN_DRIVER
+     struct wpa_ssid *selected_ssid;
+ #endif /* TI_WLAN_DRIVER */
  
  	/* cmd: "<network id>" or "any" */
  	if (os_strcmp(cmd, "any") == 0) {
***************
*** 571,576 ****
--- 653,678 ----
  	if (ssid != wpa_s->current_ssid && wpa_s->current_ssid)
  		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
  
+ #ifdef TI_WLAN_DRIVER
+     selected_ssid = ssid;
+ 
+ 	/* remove all matching networks */
+ 	ssid = wpa_s->conf->ssid;
+ 	while (ssid) 
+ 	{
+ 		if ((ssid != selected_ssid) && (wpa_supplicant_compare_ssid(ssid, selected_ssid)))
+       	{
+         	wpa_printf(MSG_DEBUG, "CTRL_IFACE: found matching block !!! ssid = %s",ssid->ssid);
+          	if (wpa_config_remove_network(wpa_s->conf, ssid->id) < 0)
+          	{
+             	wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not remove network id=%d", ssid->id);
+          	}
+          	break;
+       	}
+ 		ssid = ssid->next;
+ 	}
+ #endif /* TI_WLAN_DRIVER */
+ 
  	/* Mark all other networks disabled and trigger reassociation */
  	ssid = wpa_s->conf->ssid;
  	while (ssid) {
***************
*** 624,634 ****
  	id = atoi(cmd);
  	wpa_printf(MSG_DEBUG, "CTRL_IFACE: DISABLE_NETWORK id=%d", id);
  
! 	ssid = wpa_config_get_network(wpa_s->conf, id);
! 	if (ssid == NULL) {
! 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
! 			   "id=%d", id);
! 		return -1;
  	}
  
  	if (ssid == wpa_s->current_ssid)
--- 726,747 ----
  	id = atoi(cmd);
  	wpa_printf(MSG_DEBUG, "CTRL_IFACE: DISABLE_NETWORK id=%d", id);
  
! 	if(id == -1)
! 	{
! 		/* disable the current network */
! 		if(wpa_s->current_ssid)
! 		ssid = wpa_s->current_ssid;
! 		else
! 			return -1;
! 	}
! 	else
! 	{
! 		ssid = wpa_config_get_network(wpa_s->conf, id);
! 		if (ssid == NULL) {
! 			wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
! 				   "id=%d", id);
! 			return -1;
! 		}
  	}
  
  	if (ssid == wpa_s->current_ssid)
***************
*** 1063,1069 ****
  	return 0;
  }
  
- 
  char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
  					 char *buf, size_t *resp_len)
  {
--- 1176,1181 ----
Only in wpa_suppl: ctrl_iface.d
Only in wpa_suppl: ctrl_iface.o
Only in wpa_suppl: ctrl_iface_unix.d
Only in wpa_suppl: ctrl_iface_unix.o
Only in wpa_supplicant-0.5.7: .cvsignore
Only in wpa_suppl: d2utmp0Deuc9
Only in wpa_suppl: d2utmp0eIxAn
Only in wpa_suppl: d2utmp0oMyod
Only in wpa_suppl: d2utmp0U3VSb
Only in wpa_suppl: d2utmp11LWlV
Only in wpa_suppl: d2utmp14oW6N
Only in wpa_suppl: d2utmp1vohpm
Only in wpa_suppl: d2utmp2JRlWK
Only in wpa_suppl: d2utmp2vq5Rp
Only in wpa_suppl: d2utmp301LCp
Only in wpa_suppl: d2utmp3ewI81
Only in wpa_suppl: d2utmp3uKflx
Only in wpa_suppl: d2utmp42weVC
Only in wpa_suppl: d2utmp49ToKD
Only in wpa_suppl: d2utmp57UsYg
Only in wpa_suppl: d2utmp5gIbeT
Only in wpa_suppl: d2utmp5llgLm
Only in wpa_suppl: d2utmp5v4ZtA
Only in wpa_suppl: d2utmp5v6Kbf
Only in wpa_suppl: d2utmp612Xih
Only in wpa_suppl: d2utmp6GFMPN
Only in wpa_suppl: d2utmp6Kpu6W
Only in wpa_suppl: d2utmp6krSSf
Only in wpa_suppl: d2utmp6VUVOO
Only in wpa_suppl: d2utmp7QgL3G
Only in wpa_suppl: d2utmp87TL88
Only in wpa_suppl: d2utmp8aYzK5
Only in wpa_suppl: d2utmp8TJzat
Only in wpa_suppl: d2utmp92sHTS
Only in wpa_suppl: d2utmpa807Pq
Only in wpa_suppl: d2utmpAa0XhD
Only in wpa_suppl: d2utmpACmCs8
Only in wpa_suppl: d2utmpad0MdS
Only in wpa_suppl: d2utmpAfpV0G
Only in wpa_suppl: d2utmpaNDJnW
Only in wpa_suppl: d2utmpAPFTwJ
Only in wpa_suppl: d2utmpAprb8Z
Only in wpa_suppl: d2utmpaTDto7
Only in wpa_suppl: d2utmpazrgZ9
Only in wpa_suppl: d2utmpBe2Liu
Only in wpa_suppl: d2utmpBHVT5N
Only in wpa_suppl: d2utmpbMAsWG
Only in wpa_suppl: d2utmpbR7Dcc
Only in wpa_suppl: d2utmpbu4joQ
Only in wpa_suppl: d2utmpBvPXcB
Only in wpa_suppl: d2utmpBw7DxK
Only in wpa_suppl: d2utmpbz8Uze
Only in wpa_suppl: d2utmpc5G8rp
Only in wpa_suppl: d2utmpcDw3J7
Only in wpa_suppl: d2utmpCMkUBC
Only in wpa_suppl: d2utmpCtDPXv
Only in wpa_suppl: d2utmpcVrtAL
Only in wpa_suppl: d2utmpCyjqNL
Only in wpa_suppl: d2utmpCZ8JJp
Only in wpa_suppl: d2utmpd33u8v
Only in wpa_suppl: d2utmpdaGoce
Only in wpa_suppl: d2utmpdEaluF
Only in wpa_suppl: d2utmpDF5eLR
Only in wpa_suppl: d2utmpdF7Kwg
Only in wpa_suppl: d2utmpDynXly
Only in wpa_suppl: d2utmpdyOLw6
Only in wpa_suppl: d2utmpE0v1s6
Only in wpa_suppl: d2utmpe0wd72
Only in wpa_suppl: d2utmpeaAIHF
Only in wpa_suppl: d2utmpEcODJw
Only in wpa_suppl: d2utmpEf5RZm
Only in wpa_suppl: d2utmpEhiTB1
Only in wpa_suppl: d2utmpEJcfUz
Only in wpa_suppl: d2utmpElDneu
Only in wpa_suppl: d2utmpemPKXw
Only in wpa_suppl: d2utmpepPD5l
Only in wpa_suppl: d2utmpEqW11L
Only in wpa_suppl: d2utmpETzc1Y
Only in wpa_suppl: d2utmpf1pIAo
Only in wpa_suppl: d2utmpf2LsKF
Only in wpa_suppl: d2utmpF6a57C
Only in wpa_suppl: d2utmpfL6FE1
Only in wpa_suppl: d2utmpfMMI60
Only in wpa_suppl: d2utmpFtaMSB
Only in wpa_suppl: d2utmpfTzgap
Only in wpa_suppl: d2utmpFZb6Do
Only in wpa_suppl: d2utmpGInich
Only in wpa_suppl: d2utmpgIsx4a
Only in wpa_suppl: d2utmpGKqbet
Only in wpa_suppl: d2utmpGVfQEZ
Only in wpa_suppl: d2utmpgZQlnG
Only in wpa_suppl: d2utmpH99SzB
Only in wpa_suppl: d2utmpHeFLLE
Only in wpa_suppl: d2utmphFWaIj
Only in wpa_suppl: d2utmphGgQ0z
Only in wpa_suppl: d2utmphhaEhE
Only in wpa_suppl: d2utmphlIuH2
Only in wpa_suppl: d2utmphlmbe0
Only in wpa_suppl: d2utmphruEWl
Only in wpa_suppl: d2utmphwe54O
Only in wpa_suppl: d2utmpHz5soB
Only in wpa_suppl: d2utmpIbU7fi
Only in wpa_suppl: d2utmpibuXKv
Only in wpa_suppl: d2utmpiJqdQq
Only in wpa_suppl: d2utmpIJRNYi
Only in wpa_suppl: d2utmpikQXVP
Only in wpa_suppl: d2utmpizqgg8
Only in wpa_suppl: d2utmpJ5vVo4
Only in wpa_suppl: d2utmpjjffsQ
Only in wpa_suppl: d2utmpjOgFIS
Only in wpa_suppl: d2utmpJRm6De
Only in wpa_suppl: d2utmpk8C1ow
Only in wpa_suppl: d2utmpKaH1tM
Only in wpa_suppl: d2utmpkbgaAK
Only in wpa_suppl: d2utmpkDBS63
Only in wpa_suppl: d2utmpKI2XQt
Only in wpa_suppl: d2utmpkX9doY
Only in wpa_suppl: d2utmpL08odf
Only in wpa_suppl: d2utmpl2ToNs
Only in wpa_suppl: d2utmplA0udn
Only in wpa_suppl: d2utmplihOkq
Only in wpa_suppl: d2utmpLMtQES
Only in wpa_suppl: d2utmpMCljZA
Only in wpa_suppl: d2utmpMDH7be
Only in wpa_suppl: d2utmpNsn4Ub
Only in wpa_suppl: d2utmpOaEJ49
Only in wpa_suppl: d2utmpObs9Fj
Only in wpa_suppl: d2utmpoCPJF0
Only in wpa_suppl: d2utmpOnOutx
Only in wpa_suppl: d2utmpoW5rDy
Only in wpa_suppl: d2utmpOybdTp
Only in wpa_suppl: d2utmpPBA0RY
Only in wpa_suppl: d2utmpPV90UV
Only in wpa_suppl: d2utmppvM33K
Only in wpa_suppl: d2utmpPw7awM
Only in wpa_suppl: d2utmpQ1C72F
Only in wpa_suppl: d2utmpQd0yX6
Only in wpa_suppl: d2utmpqQVB0S
Only in wpa_suppl: d2utmpQYRr9A
Only in wpa_suppl: d2utmpRCuwIF
Only in wpa_suppl: d2utmprJuhr2
Only in wpa_suppl: d2utmpRNPntB
Only in wpa_suppl: d2utmprVBmAZ
Only in wpa_suppl: d2utmprx7Gkm
Only in wpa_suppl: d2utmprXOGRc
Only in wpa_suppl: d2utmprZilCL
Only in wpa_suppl: d2utmpSAmPmz
Only in wpa_suppl: d2utmpSBEwrN
Only in wpa_suppl: d2utmpSbhyIY
Only in wpa_suppl: d2utmpsUt60s
Only in wpa_suppl: d2utmpsWKtMh
Only in wpa_suppl: d2utmpTFhz0w
Only in wpa_suppl: d2utmptKIxXQ
Only in wpa_suppl: d2utmptMpSjz
Only in wpa_suppl: d2utmpTrVaqI
Only in wpa_suppl: d2utmpTZ8YUt
Only in wpa_suppl: d2utmpuEnDSx
Only in wpa_suppl: d2utmpV3IDxI
Only in wpa_suppl: d2utmpv8x86l
Only in wpa_suppl: d2utmpV9cEVE
Only in wpa_suppl: d2utmpvH8AKI
Only in wpa_suppl: d2utmpVjRjBA
Only in wpa_suppl: d2utmpVkHjjq
Only in wpa_suppl: d2utmpvLo9DJ
Only in wpa_suppl: d2utmpVLrF79
Only in wpa_suppl: d2utmpvpkOtm
Only in wpa_suppl: d2utmpVVSFjv
Only in wpa_suppl: d2utmpw1MB3J
Only in wpa_suppl: d2utmpw7r07a
Only in wpa_suppl: d2utmpwcqblF
Only in wpa_suppl: d2utmpWfNjkE
Only in wpa_suppl: d2utmpwR7lMf
Only in wpa_suppl: d2utmpWztFyJ
Only in wpa_suppl: d2utmpxf5A5Y
Only in wpa_suppl: d2utmpxf5jFz
Only in wpa_suppl: d2utmpXfXmlf
Only in wpa_suppl: d2utmpxKuSVN
Only in wpa_suppl: d2utmpxTKNKc
Only in wpa_suppl: d2utmpy6FMae
Only in wpa_suppl: d2utmpyCwlOh
Only in wpa_suppl: d2utmpyxtNRq
Only in wpa_suppl: d2utmpYYywlG
Only in wpa_suppl: d2utmpZ5aB7U
Only in wpa_suppl: d2utmpzajRnT
Only in wpa_suppl: d2utmpzbZGGn
Only in wpa_suppl: d2utmpzFn1EP
Only in wpa_suppl: d2utmpZFomTB
Only in wpa_suppl: d2utmpZkdQB5
Only in wpa_suppl: d2utmpZm0Yl2
Only in wpa_suppl: d2utmpzoFsDM
Only in wpa_suppl: d2utmpZwFmTQ
diff -cr wpa_supplicant-0.5.7/dbus_dict_helpers.c wpa_suppl/dbus_dict_helpers.c
*** wpa_supplicant-0.5.7/dbus_dict_helpers.c	2009-08-16 14:24:56.001357000 +0300
--- wpa_suppl/dbus_dict_helpers.c	2007-11-07 16:23:57.000000000 +0200
***************
*** 902,910 ****
  
  error:
  	if (entry) {
! 		wpa_dbus_dict_entry_clear(entry);
! 		entry->type = DBUS_TYPE_INVALID;
! 		entry->array_type = DBUS_TYPE_INVALID;
  	}
  
  	return FALSE;
--- 902,910 ----
  
  error:
  	if (entry) {
! 	wpa_dbus_dict_entry_clear(entry);
! 	entry->type = DBUS_TYPE_INVALID;
! 	entry->array_type = DBUS_TYPE_INVALID;
  	}
  
  	return FALSE;
diff -cr wpa_supplicant-0.5.7/dbus-wpa_supplicant.conf wpa_suppl/dbus-wpa_supplicant.conf
*** wpa_supplicant-0.5.7/dbus-wpa_supplicant.conf	2006-06-26 05:54:48.000000000 +0300
--- wpa_suppl/dbus-wpa_supplicant.conf	2007-11-07 16:23:55.000000000 +0200
***************
*** 1,20 ****
! <!DOCTYPE busconfig PUBLIC
!  "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
!  "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
! <busconfig>
!         <policy user="root">
!                 <allow own="fi.epitest.hostap.WPASupplicant"/>
! 
!                 <allow send_destination="fi.epitest.hostap.WPASupplicant"/>
!                 <allow send_interface="fi.epitest.hostap.WPASupplicant"/>
!         </policy>
!         <policy at_console="true">
!                 <allow send_destination="fi.epitest.hostap.WPASupplicant"/>
!                 <allow send_interface="fi.epitest.hostap.WPASupplicant"/>
!         </policy>
!         <policy context="default">
!                 <deny own="fi.epitest.hostap.WPASupplicant"/>
!                 <deny send_destination="fi.epitest.hostap.WPASupplicant"/>
!                 <deny send_interface="fi.epitest.hostap.WPASupplicant"/>
!         </policy>
! </busconfig>
--- 1,20 ----
! <!DOCTYPE busconfig PUBLIC
!  "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
!  "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
! <busconfig>
!         <policy user="root">
!                 <allow own="fi.epitest.hostap.WPASupplicant"/>
! 
!                 <allow send_destination="fi.epitest.hostap.WPASupplicant"/>
!                 <allow send_interface="fi.epitest.hostap.WPASupplicant"/>
!         </policy>
!         <policy at_console="true">
!                 <allow send_destination="fi.epitest.hostap.WPASupplicant"/>
!                 <allow send_interface="fi.epitest.hostap.WPASupplicant"/>
!         </policy>
!         <policy context="default">
!                 <deny own="fi.epitest.hostap.WPASupplicant"/>
!                 <deny send_destination="fi.epitest.hostap.WPASupplicant"/>
!                 <deny send_interface="fi.epitest.hostap.WPASupplicant"/>
!         </policy>
! </busconfig>
diff -cr wpa_supplicant-0.5.7/defconfig wpa_suppl/defconfig
*** wpa_supplicant-0.5.7/defconfig	2006-10-29 19:27:50.000000000 +0200
--- wpa_suppl/defconfig	2007-11-07 16:23:59.000000000 +0200
***************
*** 1,313 ****
! # Example wpa_supplicant build time configuration
! #
! # This file lists the configuration options that are used when building the
! # hostapd binary. All lines starting with # are ignored. Configuration option
! # lines must be commented out complete, if they are not to be included, i.e.,
! # just setting VARIABLE=n is not disabling that variable.
! #
! # This file is included in Makefile, so variables like CFLAGS and LIBS can also
! # be modified from here. In most cases, these lines should use += in order not
! # to override previous values of the variables.
! 
! 
! # Uncomment following two lines and fix the paths if you have installed OpenSSL
! # or GnuTLS in non-default location
! #CFLAGS += -I/usr/local/openssl/include
! #LIBS += -L/usr/local/openssl/lib
! 
! # Some Red Hat versions seem to include kerberos header files from OpenSSL, but
! # the kerberos files are not in the default include path. Following line can be
! # used to fix build issues on such systems (krb5.h not found).
! #CFLAGS += -I/usr/include/kerberos
! 
! # Example configuration for various cross-compilation platforms
! 
! #### sveasoft (e.g., for Linksys WRT54G) ######################################
! #CC=mipsel-uclibc-gcc
! #CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
! #CFLAGS += -Os
! #CPPFLAGS += -I../src/include -I../../src/router/openssl/include
! #LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
! ###############################################################################
! 
! #### openwrt (e.g., for Linksys WRT54G) #######################################
! #CC=mipsel-uclibc-gcc
! #CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
! #CFLAGS += -Os
! #CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
! #	-I../WRT54GS/release/src/include
! #LIBS = -lssl
! ###############################################################################
! 
! 
! # Driver interface for Host AP driver
! CONFIG_DRIVER_HOSTAP=y
! 
! # Driver interface for Agere driver
! #CONFIG_DRIVER_HERMES=y
! # Change include directories to match with the local setup
! #CFLAGS += -I../../hcf -I../../include -I../../include/hcf
! #CFLAGS += -I../../include/wireless
! 
! # Driver interface for madwifi driver
! #CONFIG_DRIVER_MADWIFI=y
! # Change include directories to match with the local setup
! #CFLAGS += -I../madwifi/wpa
! 
! # Driver interface for Prism54 driver
! # (Note: Prism54 is not yet supported, i.e., this will not work as-is and is
! # for developers only)
! #CONFIG_DRIVER_PRISM54=y
! 
! # Driver interface for ndiswrapper
! #CONFIG_DRIVER_NDISWRAPPER=y
! 
! # Driver interface for Atmel driver
! CONFIG_DRIVER_ATMEL=y
! 
! # Driver interface for Broadcom driver
! #CONFIG_DRIVER_BROADCOM=y
! # Example path for wlioctl.h; change to match your configuration
! #CFLAGS += -I/opt/WRT54GS/release/src/include
! 
! # Driver interface for Intel ipw2100/2200 driver
! #CONFIG_DRIVER_IPW=y
! 
! # Driver interface for generic Linux wireless extensions
! CONFIG_DRIVER_WEXT=y
! 
! # Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
! #CONFIG_DRIVER_BSD=y
! #CFLAGS += -I/usr/local/include
! #LIBS += -L/usr/local/lib
! 
! # Driver interface for Windows NDIS
! #CONFIG_DRIVER_NDIS=y
! #CFLAGS += -I/usr/include/w32api/ddk
! #LIBS += -L/usr/local/lib
! # For native build using mingw
! #CONFIG_NATIVE_WINDOWS=y
! # Additional directories for cross-compilation on Linux host for mingw target
! #CFLAGS += -I/opt/mingw/mingw32/include/ddk
! #LIBS += -L/opt/mingw/mingw32/lib
! #CC=mingw32-gcc
! # By default, driver_ndis uses WinPcap for low-level operations. This can be
! # replaced with the following option which replaces WinPcap calls with NDISUIO.
! # However, this requires that WZC is disabled (net stop wzcsvc) before starting
! # wpa_supplicant.
! # CONFIG_USE_NDISUIO=y
! 
! # Driver interface for development testing
! #CONFIG_DRIVER_TEST=y
! 
! # Driver interface for wired Ethernet drivers
! CONFIG_DRIVER_WIRED=y
! 
! # Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
! # included)
! CONFIG_IEEE8021X_EAPOL=y
! 
! # EAP-MD5
! CONFIG_EAP_MD5=y
! 
! # EAP-MSCHAPv2
! CONFIG_EAP_MSCHAPV2=y
! 
! # EAP-TLS
! CONFIG_EAP_TLS=y
! 
! # EAL-PEAP
! CONFIG_EAP_PEAP=y
! 
! # EAP-TTLS
! CONFIG_EAP_TTLS=y
! 
! # EAP-GTC
! CONFIG_EAP_GTC=y
! 
! # EAP-OTP
! CONFIG_EAP_OTP=y
! 
! # EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
! #CONFIG_EAP_SIM=y
! 
! # EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
! #CONFIG_EAP_PSK=y
! 
! # EAP-PAX
! #CONFIG_EAP_PAX=y
! 
! # LEAP
! CONFIG_EAP_LEAP=y
! 
! # EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
! #CONFIG_EAP_AKA=y
! 
! # EAP-SAKE
! #CONFIG_EAP_SAKE=y
! 
! # EAP-GPSK
! #CONFIG_EAP_GPSK=y
! # Include support for optional SHA256 cipher suite in EAP-GPSK
! #CONFIG_EAP_GPSK_SHA256=y
! 
! # PKCS#12 (PFX) support (used to read private key and certificate file from
! # a file that usually has extension .p12 or .pfx)
! CONFIG_PKCS12=y
! 
! # Smartcard support (i.e., private key on a smartcard), e.g., with openssl
! # engine.
! CONFIG_SMARTCARD=y
! 
! # PC/SC interface for smartcards (USIM, GSM SIM)
! # Enable this if EAP-SIM or EAP-AKA is included
! #CONFIG_PCSC=y
! 
! # Development testing
! #CONFIG_EAPOL_TEST=y
! 
! # Select control interface backend for external programs, e.g, wpa_cli:
! # unix = UNIX domain sockets (default for Linux/*BSD)
! # udp = UDP sockets using localhost (127.0.0.1)
! # named_pipe = Windows Named Pipe (default for Windows)
! # y = use default (backwards compatibility)
! # If this option is commented out, control interface is not included in the
! # build.
! CONFIG_CTRL_IFACE=y
! 
! # Include support for GNU Readline and History Libraries in wpa_cli.
! # When building a wpa_cli binary for distribution, please note that these
! # libraries are licensed under GPL and as such, BSD license may not apply for
! # the resulting binary.
! #CONFIG_READLINE=y
! 
! # Remove debugging code that is printing out debug message to stdout.
! # This can be used to reduce the size of the wpa_supplicant considerably
! # if debugging code is not needed. The size reduction can be around 35%
! # (e.g., 90 kB).
! #CONFIG_NO_STDOUT_DEBUG=y
! 
! # Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
! # 35-50 kB in code size.
! #CONFIG_NO_WPA=y
! 
! # Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
! # save about 1 kB in code size when building only WPA-Personal (no EAP support)
! # or 6 kB if building for WPA-Enterprise.
! #CONFIG_NO_WPA2=y
! 
! # Remove AES extra functions. This can be used to reduce code size by about
! # 1.5 kB by removing extra AES modes that are not needed for commonly used
! # client configurations (they are needed for some EAP types).
! #CONFIG_NO_AES_EXTRAS=y
! 
! # Select configuration backend:
! # file = text file (e.g., wpa_supplicant.conf)
! # winreg = Windows registry (see win_example.reg for an example)
! CONFIG_BACKEND=file
! 
! # Select program entry point implementation:
! # main = UNIX/POSIX like main() function (default)
! # main_winsvc = Windows service (read parameters from registry)
! # main_none = Very basic example (development use only)
! #CONFIG_MAIN=main
! 
! # Select wrapper for operatins system and C library specific functions
! # unix = UNIX/POSIX like systems (default)
! # win32 = Windows systems
! # none = Empty template
! #CONFIG_OS=unix
! 
! # Select event loop implementation
! # eloop = select() loop (default)
! # eloop_win = Windows events and WaitForMultipleObject() loop
! # eloop_none = Empty template
! #CONFIG_ELOOP=eloop
! 
! # Select layer 2 packet implementation
! # linux = Linux packet socket (default)
! # pcap = libpcap/libdnet/WinPcap
! # freebsd = FreeBSD libpcap
! # winpcap = WinPcap with receive thread
! # ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
! # none = Empty template
! #CONFIG_L2_PACKET=linux
! 
! # PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
! CONFIG_PEERKEY=y
! 
! # IEEE 802.11w (management frame protection)
! # This version is an experimental implementation based on IEEE 802.11w/D1.0
! # draft and is subject to change since the standard has not yet been finalized.
! # Driver support is also needed for IEEE 802.11w.
! #CONFIG_IEEE80211W=y
! 
! # Select TLS implementation
! # openssl = OpenSSL (default)
! # gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
! # internal = Internal TLSv1 implementation (experimental)
! # none = Empty template
! #CONFIG_TLS=openssl
! 
! # Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
! # You need CONFIG_TLS=gnutls for this to have any effect. Please note that
! # even though the core GnuTLS library is released under LGPL, this extra
! # library uses GPL and as such, the terms of GPL apply to the combination
! # of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
! # apply for distribution of the resulting binary.
! #CONFIG_GNUTLS_EXTRA=y
! 
! # If CONFIG_TLS=internal is used, additional library and include paths are
! # needed for LibTomMath. Alternatively, an integrated, minimal version of
! # LibTomMath can be used. See beginning of libtommath.c for details on benefits
! # and drawbacks of this option.
! #CONFIG_INTERNAL_LIBTOMMATH=y
! #ifndef CONFIG_INTERNAL_LIBTOMMATH
! #LTM_PATH=/usr/src/libtommath-0.39
! #CFLAGS += -I$(LTM_PATH)
! #LIBS += -L$(LTM_PATH)
! #LIBS_p += -L$(LTM_PATH)
! #endif
! 
! # Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
! # This is only for Windows builds and requires WMI-related header files and
! # WbemUuid.Lib from Platform SDK even when building with MinGW.
! #CONFIG_NDIS_EVENTS_INTEGRATED=y
! #PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
! 
! # Add support for DBus control interface
! #CONFIG_CTRL_IFACE_DBUS=y
! 
! # Add support for loading EAP methods dynamically as shared libraries.
! # When this option is enabled, each EAP method can be either included
! # statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
! # Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
! # be loaded in the beginning of the wpa_supplicant configuration file
! # (see load_dynamic_eap parameter in the example file) before being used in
! # the network blocks.
! #
! # Note that some shared parts of EAP methods are included in the main program
! # and in order to be able to use dynamic EAP methods using these parts, the
! # main program must have been build with the EAP method enabled (=y or =dyn).
! # This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
! # unless at least one of them was included in the main build to force inclusion
! # of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
! # in the main build to be able to load these methods dynamically.
! #
! # Please also note that using dynamic libraries will increase the total binary
! # size. Thus, it may not be the best option for targets that have limited
! # amount of memory/flash.
! #CONFIG_DYNAMIC_EAP_METHODS=y
! 
! # Include client MLME (management frame processing).
! # This can be used to move MLME processing of Devicescape IEEE 802.11 stack
! # into user space.
! #CONFIG_CLIENT_MLME=y
! # Currently, driver_devicescape.c build requires some additional parameters
! # to be able to include some of the kernel header files. Following lines can
! # be used to set these (WIRELESS_DEV must point to the root directory of the
! # wireless-dev.git tree).
! #WIRELESS_DEV=/usr/src/wireless-dev
! #CFLAGS += -I$(WIRELESS_DEV)/include
! #CFLAGS += -I$(WIRELESS_DEV)/net/d80211
! #CFLAGS += -D_LINUX_TYPES_H
--- 1,313 ----
! # Example wpa_supplicant build time configuration
! #
! # This file lists the configuration options that are used when building the
! # hostapd binary. All lines starting with # are ignored. Configuration option
! # lines must be commented out complete, if they are not to be included, i.e.,
! # just setting VARIABLE=n is not disabling that variable.
! #
! # This file is included in Makefile, so variables like CFLAGS and LIBS can also
! # be modified from here. In most cases, these lines should use += in order not
! # to override previous values of the variables.
! 
! 
! # Uncomment following two lines and fix the paths if you have installed OpenSSL
! # or GnuTLS in non-default location
! #CFLAGS += -I/usr/local/openssl/include
! #LIBS += -L/usr/local/openssl/lib
! 
! # Some Red Hat versions seem to include kerberos header files from OpenSSL, but
! # the kerberos files are not in the default include path. Following line can be
! # used to fix build issues on such systems (krb5.h not found).
! #CFLAGS += -I/usr/include/kerberos
! 
! # Example configuration for various cross-compilation platforms
! 
! #### sveasoft (e.g., for Linksys WRT54G) ######################################
! #CC=mipsel-uclibc-gcc
! #CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
! #CFLAGS += -Os
! #CPPFLAGS += -I../src/include -I../../src/router/openssl/include
! #LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
! ###############################################################################
! 
! #### openwrt (e.g., for Linksys WRT54G) #######################################
! #CC=mipsel-uclibc-gcc
! #CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
! #CFLAGS += -Os
! #CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
! #	-I../WRT54GS/release/src/include
! #LIBS = -lssl
! ###############################################################################
! 
! 
! # Driver interface for Host AP driver
! CONFIG_DRIVER_HOSTAP=y
! 
! # Driver interface for Agere driver
! #CONFIG_DRIVER_HERMES=y
! # Change include directories to match with the local setup
! #CFLAGS += -I../../hcf -I../../include -I../../include/hcf
! #CFLAGS += -I../../include/wireless
! 
! # Driver interface for madwifi driver
! #CONFIG_DRIVER_MADWIFI=y
! # Change include directories to match with the local setup
! #CFLAGS += -I../madwifi/wpa
! 
! # Driver interface for Prism54 driver
! # (Note: Prism54 is not yet supported, i.e., this will not work as-is and is
! # for developers only)
! #CONFIG_DRIVER_PRISM54=y
! 
! # Driver interface for ndiswrapper
! #CONFIG_DRIVER_NDISWRAPPER=y
! 
! # Driver interface for Atmel driver
! CONFIG_DRIVER_ATMEL=y
! 
! # Driver interface for Broadcom driver
! #CONFIG_DRIVER_BROADCOM=y
! # Example path for wlioctl.h; change to match your configuration
! #CFLAGS += -I/opt/WRT54GS/release/src/include
! 
! # Driver interface for Intel ipw2100/2200 driver
! #CONFIG_DRIVER_IPW=y
! 
! # Driver interface for generic Linux wireless extensions
! CONFIG_DRIVER_WEXT=y
! 
! # Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
! #CONFIG_DRIVER_BSD=y
! #CFLAGS += -I/usr/local/include
! #LIBS += -L/usr/local/lib
! 
! # Driver interface for Windows NDIS
! #CONFIG_DRIVER_NDIS=y
! #CFLAGS += -I/usr/include/w32api/ddk
! #LIBS += -L/usr/local/lib
! # For native build using mingw
! #CONFIG_NATIVE_WINDOWS=y
! # Additional directories for cross-compilation on Linux host for mingw target
! #CFLAGS += -I/opt/mingw/mingw32/include/ddk
! #LIBS += -L/opt/mingw/mingw32/lib
! #CC=mingw32-gcc
! # By default, driver_ndis uses WinPcap for low-level operations. This can be
! # replaced with the following option which replaces WinPcap calls with NDISUIO.
! # However, this requires that WZC is disabled (net stop wzcsvc) before starting
! # wpa_supplicant.
! # CONFIG_USE_NDISUIO=y
! 
! # Driver interface for development testing
! #CONFIG_DRIVER_TEST=y
! 
! # Driver interface for wired Ethernet drivers
! CONFIG_DRIVER_WIRED=y
! 
! # Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
! # included)
! CONFIG_IEEE8021X_EAPOL=y
! 
! # EAP-MD5
! CONFIG_EAP_MD5=y
! 
! # EAP-MSCHAPv2
! CONFIG_EAP_MSCHAPV2=y
! 
! # EAP-TLS
! CONFIG_EAP_TLS=y
! 
! # EAL-PEAP
! CONFIG_EAP_PEAP=y
! 
! # EAP-TTLS
! CONFIG_EAP_TTLS=y
! 
! # EAP-GTC
! CONFIG_EAP_GTC=y
! 
! # EAP-OTP
! CONFIG_EAP_OTP=y
! 
! # EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
! #CONFIG_EAP_SIM=y
! 
! # EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
! #CONFIG_EAP_PSK=y
! 
! # EAP-PAX
! #CONFIG_EAP_PAX=y
! 
! # LEAP
! CONFIG_EAP_LEAP=y
! 
! # EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
! #CONFIG_EAP_AKA=y
! 
! # EAP-SAKE
! #CONFIG_EAP_SAKE=y
! 
! # EAP-GPSK
! #CONFIG_EAP_GPSK=y
! # Include support for optional SHA256 cipher suite in EAP-GPSK
! #CONFIG_EAP_GPSK_SHA256=y
! 
! # PKCS#12 (PFX) support (used to read private key and certificate file from
! # a file that usually has extension .p12 or .pfx)
! CONFIG_PKCS12=y
! 
! # Smartcard support (i.e., private key on a smartcard), e.g., with openssl
! # engine.
! CONFIG_SMARTCARD=y
! 
! # PC/SC interface for smartcards (USIM, GSM SIM)
! # Enable this if EAP-SIM or EAP-AKA is included
! #CONFIG_PCSC=y
! 
! # Development testing
! #CONFIG_EAPOL_TEST=y
! 
! # Select control interface backend for external programs, e.g, wpa_cli:
! # unix = UNIX domain sockets (default for Linux/*BSD)
! # udp = UDP sockets using localhost (127.0.0.1)
! # named_pipe = Windows Named Pipe (default for Windows)
! # y = use default (backwards compatibility)
! # If this option is commented out, control interface is not included in the
! # build.
! CONFIG_CTRL_IFACE=y
! 
! # Include support for GNU Readline and History Libraries in wpa_cli.
! # When building a wpa_cli binary for distribution, please note that these
! # libraries are licensed under GPL and as such, BSD license may not apply for
! # the resulting binary.
! #CONFIG_READLINE=y
! 
! # Remove debugging code that is printing out debug message to stdout.
! # This can be used to reduce the size of the wpa_supplicant considerably
! # if debugging code is not needed. The size reduction can be around 35%
! # (e.g., 90 kB).
! #CONFIG_NO_STDOUT_DEBUG=y
! 
! # Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
! # 35-50 kB in code size.
! #CONFIG_NO_WPA=y
! 
! # Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
! # save about 1 kB in code size when building only WPA-Personal (no EAP support)
! # or 6 kB if building for WPA-Enterprise.
! #CONFIG_NO_WPA2=y
! 
! # Remove AES extra functions. This can be used to reduce code size by about
! # 1.5 kB by removing extra AES modes that are not needed for commonly used
! # client configurations (they are needed for some EAP types).
! #CONFIG_NO_AES_EXTRAS=y
! 
! # Select configuration backend:
! # file = text file (e.g., wpa_supplicant.conf)
! # winreg = Windows registry (see win_example.reg for an example)
! CONFIG_BACKEND=file
! 
! # Select program entry point implementation:
! # main = UNIX/POSIX like main() function (default)
! # main_winsvc = Windows service (read parameters from registry)
! # main_none = Very basic example (development use only)
! #CONFIG_MAIN=main
! 
! # Select wrapper for operatins system and C library specific functions
! # unix = UNIX/POSIX like systems (default)
! # win32 = Windows systems
! # none = Empty template
! #CONFIG_OS=unix
! 
! # Select event loop implementation
! # eloop = select() loop (default)
! # eloop_win = Windows events and WaitForMultipleObject() loop
! # eloop_none = Empty template
! #CONFIG_ELOOP=eloop
! 
! # Select layer 2 packet implementation
! # linux = Linux packet socket (default)
! # pcap = libpcap/libdnet/WinPcap
! # freebsd = FreeBSD libpcap
! # winpcap = WinPcap with receive thread
! # ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
! # none = Empty template
! #CONFIG_L2_PACKET=linux
! 
! # PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
! CONFIG_PEERKEY=y
! 
! # IEEE 802.11w (management frame protection)
! # This version is an experimental implementation based on IEEE 802.11w/D1.0
! # draft and is subject to change since the standard has not yet been finalized.
! # Driver support is also needed for IEEE 802.11w.
! #CONFIG_IEEE80211W=y
! 
! # Select TLS implementation
! # openssl = OpenSSL (default)
! # gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
! # internal = Internal TLSv1 implementation (experimental)
! # none = Empty template
! #CONFIG_TLS=openssl
! 
! # Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
! # You need CONFIG_TLS=gnutls for this to have any effect. Please note that
! # even though the core GnuTLS library is released under LGPL, this extra
! # library uses GPL and as such, the terms of GPL apply to the combination
! # of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
! # apply for distribution of the resulting binary.
! #CONFIG_GNUTLS_EXTRA=y
! 
! # If CONFIG_TLS=internal is used, additional library and include paths are
! # needed for LibTomMath. Alternatively, an integrated, minimal version of
! # LibTomMath can be used. See beginning of libtommath.c for details on benefits
! # and drawbacks of this option.
! #CONFIG_INTERNAL_LIBTOMMATH=y
! #ifndef CONFIG_INTERNAL_LIBTOMMATH
! #LTM_PATH=/usr/src/libtommath-0.39
! #CFLAGS += -I$(LTM_PATH)
! #LIBS += -L$(LTM_PATH)
! #LIBS_p += -L$(LTM_PATH)
! #endif
! 
! # Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
! # This is only for Windows builds and requires WMI-related header files and
! # WbemUuid.Lib from Platform SDK even when building with MinGW.
! #CONFIG_NDIS_EVENTS_INTEGRATED=y
! #PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
! 
! # Add support for DBus control interface
! #CONFIG_CTRL_IFACE_DBUS=y
! 
! # Add support for loading EAP methods dynamically as shared libraries.
! # When this option is enabled, each EAP method can be either included
! # statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
! # Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
! # be loaded in the beginning of the wpa_supplicant configuration file
! # (see load_dynamic_eap parameter in the example file) before being used in
! # the network blocks.
! #
! # Note that some shared parts of EAP methods are included in the main program
! # and in order to be able to use dynamic EAP methods using these parts, the
! # main program must have been build with the EAP method enabled (=y or =dyn).
! # This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
! # unless at least one of them was included in the main build to force inclusion
! # of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
! # in the main build to be able to load these methods dynamically.
! #
! # Please also note that using dynamic libraries will increase the total binary
! # size. Thus, it may not be the best option for targets that have limited
! # amount of memory/flash.
! #CONFIG_DYNAMIC_EAP_METHODS=y
! 
! # Include client MLME (management frame processing).
! # This can be used to move MLME processing of Devicescape IEEE 802.11 stack
! # into user space.
! #CONFIG_CLIENT_MLME=y
! # Currently, driver_devicescape.c build requires some additional parameters
! # to be able to include some of the kernel header files. Following lines can
! # be used to set these (WIRELESS_DEV must point to the root directory of the
! # wireless-dev.git tree).
! #WIRELESS_DEV=/usr/src/wireless-dev
! #CFLAGS += -I$(WIRELESS_DEV)/include
! #CFLAGS += -I$(WIRELESS_DEV)/net/d80211
! #CFLAGS += -D_LINUX_TYPES_H
Only in wpa_suppl: .depend
Only in wpa_suppl: des.d
Only in wpa_suppl: des.o
Only in wpa_supplicant-0.5.7: doc
diff -cr wpa_supplicant-0.5.7/driver.h wpa_suppl/driver.h
*** wpa_supplicant-0.5.7/driver.h	2009-08-16 14:24:56.001560000 +0300
--- wpa_suppl/driver.h	2007-11-07 16:24:03.000000000 +0200
***************
*** 752,757 ****
--- 752,771 ----
  	 * (management frame processing) to wpa_supplicant.
  	 */
  	 int (*mlme_remove_sta)(void *priv, const u8 *addr);
+ 
+ #ifdef CONFIG_EAP_WSC
+ 	/**
+ 	 * set_wsc_mode - set the driver wsc mode
+ 	 * @priv: Private driver interface data
+ 	 * @WscMode: wsc mode
+ 	 * @probeReqBuf: the probe request
+ 	 * Returns: 0 on success, -1 on failure
+ 	 *
+ 	 * This function is only needed for drivers that export MLME
+ 	 * (management frame processing) to wpa_supplicant.
+ 	 */
+ 	 int (*set_wsc_mode)(void *priv, const u32 WscMode, const void* probeReqBuf, int probeReqBufLen);	
+ #endif
  };
  
  #endif /* DRIVER_H */
Only in wpa_suppl: drivers.d
Only in wpa_suppl: drivers.o
diff -cr wpa_supplicant-0.5.7/driver_wext.c wpa_suppl/driver_wext.c
*** wpa_supplicant-0.5.7/driver_wext.c	2009-08-16 14:24:57.000608000 +0300
--- wpa_suppl/driver_wext.c	2008-01-17 13:08:53.000000000 +0200
***************
*** 1,6 ****
  /*
   * WPA Supplicant - driver interaction with generic Linux Wireless Extensions
!  * Copyright (c) 2003-2006, Jouni Malinen <jkmaline@cc.hut.fi>
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 as
--- 1,6 ----
  /*
   * WPA Supplicant - driver interaction with generic Linux Wireless Extensions
!  * Copyright (c) 2003-2008, Jouni Malinen <jkmaline@cc.hut.fi>
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 as
***************
*** 32,37 ****
--- 32,44 ----
  #include "driver_wext.h"
  #include "wpa.h"
  
+ #ifdef CONFIG_EAP_WSC
+ #ifdef TI_WLAN_DRIVER
+ #include "TWDriver.h"
+ #include "STADExternalIf.h"
+ #endif
+ #endif
+ 
  #ifdef CONFIG_CLIENT_MLME
  #include <netpacket/packet.h>
  #include <hostapd_ioctl.h>
***************
*** 120,126 ****
  	wpa_printf(MSG_DEBUG, "WEXT: Operstate: linkmode=%d, operstate=%d",
  		   linkmode, operstate);
  
! 	ret = send(drv->event_sock, &req, req.hdr.nlmsg_len, 0);
  	if (ret < 0) {
  		wpa_printf(MSG_DEBUG, "WEXT: Sending operstate IFLA failed: "
  			   "%s (assume operstate is not supported)",
--- 127,133 ----
  	wpa_printf(MSG_DEBUG, "WEXT: Operstate: linkmode=%d, operstate=%d",
  		   linkmode, operstate);
  
!  	ret = send(drv->event_sock, &req, req.hdr.nlmsg_len, 0);
  	if (ret < 0) {
  		wpa_printf(MSG_DEBUG, "WEXT: Sending operstate IFLA failed: "
  			   "%s (assume operstate is not supported)",
***************
*** 190,202 ****
  	struct iwreq iwr;
  	int ret = 0;
  
! 	os_memset(&iwr, 0, sizeof(iwr));
  	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
  	iwr.u.ap_addr.sa_family = ARPHRD_ETHER;
  	if (bssid)
! 		os_memcpy(iwr.u.ap_addr.sa_data, bssid, ETH_ALEN);
  	else
! 		os_memset(iwr.u.ap_addr.sa_data, 0, ETH_ALEN);
  
  	if (ioctl(drv->ioctl_sock, SIOCSIWAP, &iwr) < 0) {
  		perror("ioctl[SIOCSIWAP]");
--- 197,209 ----
  	struct iwreq iwr;
  	int ret = 0;
  
!     os_memset(&iwr, 0, sizeof(iwr));
  	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
  	iwr.u.ap_addr.sa_family = ARPHRD_ETHER;
  	if (bssid)
!         os_memcpy(iwr.u.ap_addr.sa_data, bssid, ETH_ALEN);
  	else
!         os_memset(iwr.u.ap_addr.sa_data, 0, ETH_ALEN);
  
  	if (ioctl(drv->ioctl_sock, SIOCSIWAP, &iwr) < 0) {
  		perror("ioctl[SIOCSIWAP]");
***************
*** 386,391 ****
--- 393,406 ----
  		wpa_supplicant_event(ctx, EVENT_STKSTART, &data);
  #endif /* CONFIG_PEERKEY */
  	}
+ #ifdef TI_WLAN_DRIVER
+ #ifdef CONFIG_EAP_WSC
+ 	else if(((IPC_EV_DATA*)custom)->EvParams.uEventType == IPC_EVENT_WPS_SESSION_OVERLAP)
+ 	{
+ 		wpa_supplicant_event(ctx, EVENT_WSC_PBC_OVERLAP, NULL);
+ 	}
+ #endif /* CONFIG_EAP_WSC */
+ #endif /* TI_WLAN_DRIVER */
  }
  
  
***************
*** 791,797 ****
  					      const char *ifname, int *flags)
  {
  	struct ifreq ifr;
! 
  	os_memset(&ifr, 0, sizeof(ifr));
  	os_strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
  	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
--- 806,812 ----
  					      const char *ifname, int *flags)
  {
  	struct ifreq ifr;
! 	
  	os_memset(&ifr, 0, sizeof(ifr));
  	os_strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
  	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
***************
*** 1679,1685 ****
  				    reason_code);
  }
  
! 
  static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie,
  				      size_t ie_len)
  {
--- 1694,1700 ----
  				    reason_code);
  }
  
! #ifndef TI_WLAN_DRIVER
  static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie,
  				      size_t ie_len)
  {
***************
*** 1699,1704 ****
--- 1714,1720 ----
  
  	return ret;
  }
+ #endif
  
  
  static int wpa_driver_wext_cipher2wext(int cipher)
***************
*** 1802,1813 ****
--- 1818,1831 ----
  
  	if (wpa_driver_wext_set_mode(drv, params->mode) < 0)
  		ret = -1;
+ #ifndef TI_WLAN_DRIVER
  	/* TODO: should consider getting wpa version and cipher/key_mgmt suites
  	 * from configuration, not from here, where only the selected suite is
  	 * available */
  	if (wpa_driver_wext_set_gen_ie(drv, params->wpa_ie, params->wpa_ie_len)
  	    < 0)
  		ret = -1;
+ #endif
  	if (params->wpa_ie == NULL || params->wpa_ie_len == 0)
  		value = IW_AUTH_WPA_VERSION_DISABLED;
  	else if (params->wpa_ie[0] == RSN_INFO_ELEM)
***************
*** 1845,1862 ****
  		allow_unencrypted_eapol = 0;
  	else
  		allow_unencrypted_eapol = 1;
! 	
  	if (wpa_driver_wext_set_auth_param(drv,
  					   IW_AUTH_RX_UNENCRYPTED_EAPOL,
  					   allow_unencrypted_eapol) < 0)
  		ret = -1;
  	if (params->freq && wpa_driver_wext_set_freq(drv, params->freq) < 0)
  		ret = -1;
- 	if (wpa_driver_wext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
- 		ret = -1;
  	if (params->bssid &&
  	    wpa_driver_wext_set_bssid(drv, params->bssid) < 0)
  		ret = -1;
  
  	return ret;
  }
--- 1863,1881 ----
  		allow_unencrypted_eapol = 0;
  	else
  		allow_unencrypted_eapol = 1;
! 
  	if (wpa_driver_wext_set_auth_param(drv,
  					   IW_AUTH_RX_UNENCRYPTED_EAPOL,
  					   allow_unencrypted_eapol) < 0)
  		ret = -1;
  	if (params->freq && wpa_driver_wext_set_freq(drv, params->freq) < 0)
  		ret = -1;
  	if (params->bssid &&
  	    wpa_driver_wext_set_bssid(drv, params->bssid) < 0)
  		ret = -1;
+ 	if (wpa_driver_wext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
+ 		ret = -1;
+ 
  
  	return ret;
  }
***************
*** 2263,2268 ****
--- 2282,2330 ----
  
  #endif /* CONFIG_CLIENT_MLME */
  
+ #ifdef CONFIG_EAP_WSC
+ static int wpa_driver_wext_set_wsc_mode(void *priv, const u32 WscMode, const void* probeReqBuf, int probeReqBufLen)
+ {
+ #ifdef TI_WLAN_DRIVER
+ 	struct wpa_driver_wext_data *drv = priv;
+ 	struct iwreq iwr;
+ 	ti_private_cmd_t private_cmd;
+ 	TWscMode WcsModeStruct;
+ 	int ret = 0;
+ 	
+ 	WcsModeStruct.WSCMode = WscMode;
+ 	memset(WcsModeStruct.probeReqWSCIE, 0, DOT11_WSC_PROBE_REQ_MAX_LENGTH);
+ 	memcpy(WcsModeStruct.probeReqWSCIE, probeReqBuf, probeReqBufLen);
+ 
+ 	private_cmd.cmd = SITE_MGR_SIMPLE_CONFIG_MODE;
+ 	private_cmd.flags = PRIVATE_CMD_SET_FLAG;
+ 	private_cmd.in_buffer = &WcsModeStruct;
+    	private_cmd.in_buffer_len = sizeof(TWscMode);
+ 	private_cmd.out_buffer = NULL;
+    	private_cmd.out_buffer_len = 0;
+ 
+ 	os_memset(&iwr, 0, sizeof(iwr));
+ 	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);	
+ 
+ 	iwr.u.data.pointer = &private_cmd;
+ 	iwr.u.data.length = sizeof(ti_private_cmd_t);
+ 	iwr.u.data.flags = 0;	
+ 
+ 	if (ioctl(drv->ioctl_sock, SIOCIWFIRSTPRIV, &iwr) < 0) {
+ 		perror("ioctl[SIOCIWFIRSTPRIV]");
+ 		ret = -1;
+ 	}
+ 
+ 	return ret;
+ #else
+ 	wpa_printf(MSG_ERROR,"wpa_driver_wext_set_wsc_mode: wpa_driver_wext_set_wsc_mode: this implementation is working only for TI WLAN driver\n");
+ 	return -1;
+ #endif
+ 
+ }
+ #endif
+ 
+ 
  
  static int wpa_driver_wext_set_param(void *priv, const char *param)
  {
***************
*** 2340,2343 ****
--- 2402,2408 ----
  	.mlme_add_sta = wpa_driver_wext_mlme_add_sta,
  	.mlme_remove_sta = wpa_driver_wext_mlme_remove_sta,
  #endif /* CONFIG_CLIENT_MLME */
+ #ifdef CONFIG_EAP_WSC
+ 	.set_wsc_mode = wpa_driver_wext_set_wsc_mode,
+ #endif
  };
Only in wpa_suppl: driver_wext.d
Only in wpa_suppl: driver_wext.o
diff -cr wpa_supplicant-0.5.7/eap.c wpa_suppl/eap.c
*** wpa_supplicant-0.5.7/eap.c	2009-08-16 14:24:57.000821000 +0300
--- wpa_suppl/eap.c	2007-11-07 16:24:27.000000000 +0200
***************
*** 50,55 ****
--- 50,59 ----
  static const char * eap_sm_decision_txt(EapDecision decision);
  #endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
  
+ #ifdef CONFIG_EAP_WSC
+ void EapWsc_EapFailureRecv(void *priv);			
+ #endif
+ 
  
  
  static Boolean eapol_get_bool(struct eap_sm *sm, enum eapol_bool_var var)
***************
*** 1126,1131 ****
--- 1130,1144 ----
  	case EAP_CODE_FAILURE:
  		wpa_printf(MSG_DEBUG, "EAP: Received EAP-Failure");
  		sm->rxFailure = TRUE;
+ 
+ #ifdef CONFIG_EAP_WSC
+ 
+ 		if (sm->m && sm->eap_method_priv)
+ 		{
+ 			EapWsc_EapFailureRecv(sm->eap_method_priv);
+ 		}
+ 		
+ #endif /* CONFIG_EAP_WSC */
  		break;
  	default:
  		wpa_printf(MSG_DEBUG, "EAP: Ignored EAP-Packet with unknown "
Only in wpa_suppl: eap.d
diff -cr wpa_supplicant-0.5.7/eap_defs.h wpa_suppl/eap_defs.h
*** wpa_supplicant-0.5.7/eap_defs.h	2009-08-16 14:24:57.001332000 +0300
--- wpa_suppl/eap_defs.h	2007-11-07 16:24:31.000000000 +0200
***************
*** 58,64 ****
--- 58,70 ----
  	EAP_TYPE_PAX = 46 /* draft-clancy-eap-pax-11.txt */,
  	EAP_TYPE_PSK = 47 /* draft-bersani-eap-psk-11.txt */,
  	EAP_TYPE_SAKE = 48 /* RFC 4763 */,
+ #ifdef CONFIG_EAP_WSC
+ 	EAP_TYPE_EXPANDED = 253 /* RFC 3748 */,
+ 	EAP_TYPE_WSC = 254, /*Wireless Simple Config */
+ #else
  	EAP_TYPE_EXPANDED = 254 /* RFC 3748 */,
+ #endif /* CONFIG_DRIVER_TI */
+ 
  	EAP_TYPE_GPSK = 255 /* EXPERIMENTAL - type not yet allocated
  			     * draft-ietf-emu-eap-gpsk-01.txt */
  } EapType;
Only in wpa_suppl: eap_md5.d
Only in wpa_suppl: eap_md5.o
diff -cr wpa_supplicant-0.5.7/eap_methods.c wpa_suppl/eap_methods.c
*** wpa_supplicant-0.5.7/eap_methods.c	2009-08-16 14:24:58.000340000 +0300
--- wpa_suppl/eap_methods.c	2007-11-07 16:24:43.000000000 +0200
***************
*** 455,460 ****
--- 455,467 ----
  	}
  #endif /* EAP_GPSK */
  
+ #ifdef CONFIG_EAP_WSC
+ 	if (ret == 0) {
+ 		int eap_peer_wsc_register(void);
+ 		ret = eap_peer_wsc_register();
+ 	}
+ #endif /* CONFIG_EAP_WSC */
+ 
  #ifdef EAP_VENDOR_TEST
  	if (ret == 0) {
  		int eap_peer_vendor_test_register(void);
Only in wpa_suppl: eap_methods.d
Only in wpa_suppl: eap_methods.o
Only in wpa_suppl: eap_mschapv2.d
Only in wpa_suppl: eap_mschapv2.o
Only in wpa_suppl: eap.o
Only in wpa_suppl: eapol_sm.d
Only in wpa_suppl: eapol_sm.o
Only in wpa_suppl: eap_peap.d
Only in wpa_suppl: eap_peap.o
diff -cr wpa_supplicant-0.5.7/eap_sake.c wpa_suppl/eap_sake.c
*** wpa_supplicant-0.5.7/eap_sake.c	2009-08-16 14:24:58.001100000 +0300
--- wpa_suppl/eap_sake.c	2007-11-07 16:24:57.000000000 +0200
***************
*** 137,151 ****
  		return NULL;
  	}
  
! 	req = (struct eap_sake_hdr *) msg;
! 	req->code = EAP_CODE_RESPONSE;
! 	req->identifier = id;
! 	req->length = htons((u16) *length);
! 	req->type = EAP_TYPE_SAKE;
! 	req->version = EAP_SAKE_VERSION;
! 	req->session_id = data->session_id;
! 	req->subtype = subtype;
! 	*payload = (u8 *) (req + 1);
  
  	return msg;
  }
--- 137,151 ----
  		return NULL;
  	}
  
! 		req = (struct eap_sake_hdr *) msg;
! 		req->code = EAP_CODE_RESPONSE;
! 		req->identifier = id;
! 		req->length = htons((u16) *length);
! 		req->type = EAP_TYPE_SAKE;
! 		req->version = EAP_SAKE_VERSION;
! 		req->session_id = data->session_id;
! 		req->subtype = subtype;
! 		*payload = (u8 *) (req + 1);
  
  	return msg;
  }
***************
*** 393,403 ****
  		return NULL;
  	}
  
! 	req = (const struct eap_sake_hdr *) reqData;
! 	subtype = req->subtype;
! 	session_id = req->session_id;
! 	pos = (const u8 *) (req + 1);
! 	end = reqData + be_to_host16(req->length);
  
  	wpa_printf(MSG_DEBUG, "EAP-SAKE: Received frame: subtype %d "
  		   "session_id %d", subtype, session_id);
--- 393,403 ----
  		return NULL;
  	}
  
! 		req = (const struct eap_sake_hdr *) reqData;
! 		subtype = req->subtype;
! 		session_id = req->session_id;
! 		pos = (const u8 *) (req + 1);
! 		end = reqData + be_to_host16(req->length);
  
  	wpa_printf(MSG_DEBUG, "EAP-SAKE: Received frame: subtype %d "
  		   "session_id %d", subtype, session_id);
Only in wpa_suppl: eap_sim_common.d
Only in wpa_suppl: eap_sim_common.o
Only in wpa_suppl: eap_sim.d
Only in wpa_suppl: eap_sim.o
Only in wpa_supplicant-0.5.7: eap_testing.txt
Only in wpa_suppl: eap_tls_common.d
Only in wpa_suppl: eap_tls_common.o
Only in wpa_suppl: eap_tls.d
Only in wpa_suppl: eap_tls.o
Only in wpa_suppl: eap_tlv.d
Only in wpa_suppl: eap_tlv.o
Only in wpa_suppl: eap_ttls.d
Only in wpa_suppl: eap_ttls.o
Only in wpa_suppl: eap_wsc.c
Only in wpa_suppl: eap_wsc.d
Only in wpa_suppl: eap_wsc.o
Only in wpa_suppl: eloop.d
Only in wpa_suppl: eloop.o
diff -cr wpa_supplicant-0.5.7/events.c wpa_suppl/events.c
*** wpa_supplicant-0.5.7/events.c	2009-08-16 14:24:59.000587000 +0300
--- wpa_suppl/events.c	2008-11-10 17:28:22.000000000 +0200
***************
*** 28,33 ****
--- 28,36 ----
  #include "wpa_ctrl.h"
  #include "eap.h"
  #include "ctrl_iface_dbus.h"
+ #ifdef CONFIG_EAP_WSC
+ #include "wsc_supplicant.h"
+ #endif
  
  
  static int wpa_supplicant_select_config(struct wpa_supplicant *wpa_s)
***************
*** 664,669 ****
--- 667,673 ----
  	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
  	if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK)
  		eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
+ 
  	/* 802.1X::portControl = Auto */
  	eapol_sm_notify_portEnabled(wpa_s->eapol, TRUE);
  	wpa_s->eapol_received = 0;
***************
*** 675,681 ****
--- 679,693 ----
  		/* Timeout for receiving the first EAPOL packet */
  		wpa_supplicant_req_auth_timeout(wpa_s, 10, 0);
  	}
+ 
  	wpa_supplicant_cancel_scan(wpa_s);
+ 
+ #ifdef CONFIG_EAP_WSC
+ 	if(wpa_s->current_ssid)
+ 	{
+ 		wsc_supplicant_event_assoc(wpa_s->current_ssid);		
+ 	}
+ #endif
  }
  
  
***************
*** 706,713 ****
  		bssid = wpa_s->pending_bssid;
  	wpa_blacklist_add(wpa_s, bssid);
  	wpa_sm_notify_disassoc(wpa_s->wpa);
! 	wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_DISCONNECTED "- Disconnect event - "
! 		"remove keys");
  	if (wpa_supplicant_dynamic_keys(wpa_s)) {
  		wpa_s->keys_cleared = 0;
  		wpa_clear_keys(wpa_s, wpa_s->bssid);
--- 718,724 ----
  		bssid = wpa_s->pending_bssid;
  	wpa_blacklist_add(wpa_s, bssid);
  	wpa_sm_notify_disassoc(wpa_s->wpa);
! 	//wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_DISCONNECTED "- Disconnect event - remove keys");
  	if (wpa_supplicant_dynamic_keys(wpa_s)) {
  		wpa_s->keys_cleared = 0;
  		wpa_clear_keys(wpa_s, wpa_s->bssid);
***************
*** 825,830 ****
--- 836,846 ----
  		wpa_supplicant_event_stkstart(wpa_s, data);
  		break;
  #endif /* CONFIG_PEERKEY */
+ #ifdef CONFIG_EAP_WSC
+ 	case EVENT_WSC_PBC_OVERLAP:
+ 		wsc_supplicant_event_overlap();
+ 		break;
+ #endif /* CONFIG_EAP_WSC */
  	default:
  		wpa_printf(MSG_INFO, "Unknown event %d", event);
  		break;
Only in wpa_suppl: events.d
Only in wpa_suppl: events.o
Only in wpa_supplicant-0.5.7: examples
Only in wpa_suppl: l2_packet_linux.d
Only in wpa_suppl: l2_packet_linux.o
Only in wpa_suppl: main.d
Only in wpa_supplicant-0.5.7: makefile
Only in wpa_suppl: Makefile
Only in wpa_suppl: md4.d
Only in wpa_suppl: md4.o
Only in wpa_suppl: md5.d
Only in wpa_suppl: md5.o
Only in wpa_suppl: memwatch.c
Only in wpa_suppl: memwatch.h
Only in wpa_suppl: ms_funcs.d
Only in wpa_suppl: ms_funcs.o
Only in wpa_suppl: my_os.c
Only in wpa_supplicant-0.5.7: nmake.mak
Only in wpa_supplicant-0.5.7: openssl-0.9.8d-tls-extensions.patch
Only in wpa_suppl: openssl-0.9.8e
Only in wpa_supplicant-0.5.7: openssl-tls-extensions.patch
Only in wpa_suppl: os.h.keep
Only in wpa_suppl: os.h.keep.1
Only in wpa_suppl: os.h.keep.2
Only in wpa_suppl: os_unix.c.keep
Only in wpa_suppl: os_unix.d
Only in wpa_suppl: os_unix.o
Only in wpa_suppl: pmksa_cache.d
Only in wpa_suppl: pmksa_cache.o
Only in wpa_suppl: preauth.c.keep
Only in wpa_suppl: preauth.d
Only in wpa_suppl: preauth.o
Only in wpa_suppl: rc4.d
Only in wpa_suppl: rc4.o
Only in wpa_supplicant-0.5.7: readme
Only in wpa_supplicant-0.5.7: readme-windows.txt
Only in wpa_suppl: sha1.d
Only in wpa_suppl: sha1.o
Only in wpa_supplicant-0.5.7: tests
Only in wpa_suppl: tls_openssl.d
Only in wpa_suppl: tls_openssl.o
Only in wpa_supplicant-0.5.7: todo.txt
Only in wpa_supplicant-0.5.7: vs2005
Only in wpa_supplicant-0.5.7: win_example.reg
diff -cr wpa_supplicant-0.5.7/wpa.c wpa_suppl/wpa.c
*** wpa_supplicant-0.5.7/wpa.c	2009-08-16 14:25:01.002062000 +0300
--- wpa_suppl/wpa.c	2009-07-16 08:02:21.000000000 +0300
***************
*** 666,673 ****
  	os_memcpy(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN);
  	WPA_PUT_LE16(hdr->version, WPA_VERSION);
  	pos = (u8 *) (hdr + 1);
! 
! 	if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
--- 666,675 ----
  	os_memcpy(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN);
  	WPA_PUT_LE16(hdr->version, WPA_VERSION);
  	pos = (u8 *) (hdr + 1);
!     
!     if (group_cipher == (WPA_CIPHER_CCMP | WPA_CIPHER_TKIP)) { // TI for Mix Mode
!         os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
! 	} else if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
***************
*** 744,750 ****
  	WPA_PUT_LE16(hdr->version, RSN_VERSION);
  	pos = (u8 *) (hdr + 1);
  
! 	if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
--- 746,754 ----
  	WPA_PUT_LE16(hdr->version, RSN_VERSION);
  	pos = (u8 *) (hdr + 1);
  
!     if (group_cipher == (WPA_CIPHER_CCMP | WPA_CIPHER_TKIP)) {
!         os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
! 	}else if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
***************
*** 1651,1656 ****
--- 1655,1669 ----
  	int ret = 0;
  
  	switch (group_cipher) {
+     case (WPA_CIPHER_TKIP | WPA_CIPHER_CCMP):
+            if (keylen != 32 && keylen != 16) {
+ 			ret = -1;
+ 			break;
+ 		}
+ 		*key_rsc_len = 6;
+ 		*alg = WPA_ALG_TKIP | WPA_ALG_CCMP;
+ 		break;
+ 
  	case WPA_CIPHER_CCMP:
  		if (keylen != 16 || maxkeylen < 16) {
  			ret = -1;
***************
*** 2178,2186 ****
  			  (u8 *) &error, sizeof(error));
  
  	if (peer) {
! 		wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error (peer "
! 			   MACSTR " mui %d error_type %d)",
! 			   MAC2STR(peer), mui, error_type);
  	} else {
  		wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error "
  			   "(mui %d error_type %d)", mui, error_type);
--- 2191,2199 ----
  			  (u8 *) &error, sizeof(error));
  
  	if (peer) {
! 	wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error (peer "
! 		   MACSTR " mui %d error_type %d)",
! 		   MAC2STR(peer), mui, error_type);
  	} else {
  		wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error "
  			   "(mui %d error_type %d)", mui, error_type);
Only in wpa_suppl: wpa.c.keep
Only in wpa_suppl: wpa_cli
Only in wpa_suppl: wpa_cli.o
Only in wpa_suppl: wpa_ctrl.d
Only in wpa_suppl: wpa_ctrl.o
Only in wpa_suppl: wpa.d
Only in wpa_supplicant-0.5.7: wpa_gui
Only in wpa_supplicant-0.5.7: wpa_gui-qt4
Only in wpa_suppl: wpa.o
Only in wpa_suppl: wpa_passphrase
Only in wpa_suppl: wpa_passphrase.o
Only in wpa_suppl: wpa_suppl.diff
Only in wpa_suppl: wpa_supplicant
diff -cr wpa_supplicant-0.5.7/wpa_supplicant.c wpa_suppl/wpa_supplicant.c
*** wpa_supplicant-0.5.7/wpa_supplicant.c	2009-08-16 14:25:01.003059000 +0300
--- wpa_suppl/wpa_supplicant.c	2009-08-12 15:17:39.000000000 +0300
***************
*** 35,40 ****
--- 35,43 ----
  #include "pmksa_cache.h"
  #include "wpa_ctrl.h"
  #include "mlme.h"
+ #ifdef CONFIG_EAP_WSC
+ #include "wsc_supplicant.h"
+ #endif
  
  const char *wpa_supplicant_version =
  "wpa_supplicant v" VERSION_STR "\n"
***************
*** 608,614 ****
  		}
  	}
  	if (wpa_s->conf)
! 		eapol_conf.fast_reauth = wpa_s->conf->fast_reauth;
  	eapol_conf.workaround = ssid->eap_workaround;
  	eapol_conf.eap_disabled = wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X &&
  		wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X_NO_WPA;
--- 611,617 ----
  		}
  	}
  	if (wpa_s->conf)
! 	eapol_conf.fast_reauth = wpa_s->conf->fast_reauth;
  	eapol_conf.workaround = ssid->eap_workaround;
  	eapol_conf.eap_disabled = wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X &&
  		wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X_NO_WPA;
***************
*** 1220,1226 ****
  		return -1;
  
  	sel = ie.group_cipher & ssid->group_cipher;
! 	if (sel & WPA_CIPHER_CCMP) {
  		wpa_s->group_cipher = WPA_CIPHER_CCMP;
  		wpa_msg(wpa_s, MSG_DEBUG, "WPA: using GTK CCMP");
  	} else if (sel & WPA_CIPHER_TKIP) {
--- 1223,1232 ----
  		return -1;
  
  	sel = ie.group_cipher & ssid->group_cipher;
!     if ( (sel & WPA_CIPHER_CCMP)&&(sel & WPA_CIPHER_TKIP)) {//TI for Mix Mode
!         wpa_s->group_cipher = WPA_CIPHER_CCMP | WPA_CIPHER_TKIP;
!         wpa_msg(wpa_s, MSG_DEBUG, "WPA: using MIX MODE");
!     } else if (sel & WPA_CIPHER_CCMP) {
  		wpa_s->group_cipher = WPA_CIPHER_CCMP;
  		wpa_msg(wpa_s, MSG_DEBUG, "WPA: using GTK CCMP");
  	} else if (sel & WPA_CIPHER_TKIP) {
***************
*** 1345,1350 ****
--- 1351,1362 ----
  	 * previous association. */
  	wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, NULL, 0);
  
+ #ifdef CONFIG_EAP_WSC
+ 	if(ssid->wsc_mode)
+ 	{
+ 		wsc_supplicant_associate(wpa_s, ssid, ssid->wsc_mode);		
+ 	}	
+ #endif
  #ifdef IEEE8021X_EAPOL
  	if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
  		if (ssid->leap) {
***************
*** 1441,1447 ****
  		/* Set the key before (and later after) association */
  		wpa_supplicant_set_wpa_none_key(wpa_s, ssid);
  	}
! 
  	wpa_drv_set_drop_unencrypted(wpa_s, use_crypt);
  	wpa_supplicant_set_state(wpa_s, WPA_ASSOCIATING);
  	os_memset(&params, 0, sizeof(params));
--- 1453,1459 ----
  		/* Set the key before (and later after) association */
  		wpa_supplicant_set_wpa_none_key(wpa_s, ssid);
  	}
! 	
  	wpa_drv_set_drop_unencrypted(wpa_s, use_crypt);
  	wpa_supplicant_set_state(wpa_s, WPA_ASSOCIATING);
  	os_memset(&params, 0, sizeof(params));
***************
*** 1453,1458 ****
--- 1465,1471 ----
  	} else {
  		params.ssid = ssid->ssid;
  		params.ssid_len = ssid->ssid_len;
+         params.bssid = ssid->bssid;
  	}
  	params.wpa_ie = wpa_ie;
  	params.wpa_ie_len = wpa_ie_len;
***************
*** 1468,1474 ****
  	}
  	params.wep_tx_keyidx = ssid->wep_tx_keyidx;
  
! #ifdef CONFIG_IEEE80211W
  	switch (ssid->ieee80211w) {
  	case NO_IEEE80211W:
  		params.mgmt_frame_protection = NO_MGMT_FRAME_PROTECTION;
--- 1481,1487 ----
  	}
  	params.wep_tx_keyidx = ssid->wep_tx_keyidx;
  
! #ifdef CONFIG_IEEE80211W		
  	switch (ssid->ieee80211w) {
  	case NO_IEEE80211W:
  		params.mgmt_frame_protection = NO_MGMT_FRAME_PROTECTION;
***************
*** 1511,1516 ****
--- 1524,1532 ----
  			timeout = 10;
  		else
  			timeout = 60;
+ #ifdef CONFIG_EAP_WSC
+ 		timeout += wsc_supplicant_associate_timeout_calc();
+ #endif
  		wpa_supplicant_req_auth_timeout(wpa_s, timeout, 0);
  	}
  
***************
*** 1553,1567 ****
  				 int reason_code)
  {
  	u8 *addr = NULL;
  	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
! 	if (os_memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0)
  	{
! 		if (wpa_s->use_client_mlme)
  			ieee80211_sta_disassociate(wpa_s, reason_code);
  		else
  			wpa_drv_disassociate(wpa_s, wpa_s->bssid, reason_code);
  		addr = wpa_s->bssid;
  	}
  	wpa_clear_keys(wpa_s, addr);
  	wpa_s->current_ssid = NULL;
  	wpa_sm_set_config(wpa_s->wpa, NULL);
--- 1569,1589 ----
  				 int reason_code)
  {
  	u8 *addr = NULL;
+ #ifdef CONFIG_EAP_WSC
+ 	if(wpa_s->current_ssid && wpa_s->current_ssid->wsc_mode)
+ 		wsc_supplicant_stop();
+ #endif
+     
  	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
!     if (os_memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0)
  	{
!         if (wpa_s->use_client_mlme)
  			ieee80211_sta_disassociate(wpa_s, reason_code);
  		else
  			wpa_drv_disassociate(wpa_s, wpa_s->bssid, reason_code);
  		addr = wpa_s->bssid;
  	}
+    
  	wpa_clear_keys(wpa_s, addr);
  	wpa_s->current_ssid = NULL;
  	wpa_sm_set_config(wpa_s->wpa, NULL);
***************
*** 1723,1739 ****
  	int res;
  	size_t ssid_len;
  	u8 bssid[ETH_ALEN];
! 
  	if (wpa_s->use_client_mlme) {
  		if (ieee80211_sta_get_ssid(wpa_s, ssid, &ssid_len)) {
! 			wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "MLME.");
  			return NULL;
  		}
  	} else {
  		res = wpa_drv_get_ssid(wpa_s, ssid);
  		if (res < 0) {
! 			wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "driver.");
  			return NULL;
  		}
--- 1745,1761 ----
  	int res;
  	size_t ssid_len;
  	u8 bssid[ETH_ALEN];
! 	
  	if (wpa_s->use_client_mlme) {
  		if (ieee80211_sta_get_ssid(wpa_s, ssid, &ssid_len)) {
!             wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "MLME.");
  			return NULL;
  		}
  	} else {
  		res = wpa_drv_get_ssid(wpa_s, ssid);
  		if (res < 0) {
!             wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "driver.");
  			return NULL;
  		}
***************
*** 1743,1749 ****
  	if (wpa_s->use_client_mlme)
  		os_memcpy(bssid, wpa_s->bssid, ETH_ALEN);
  	else if (wpa_drv_get_bssid(wpa_s, bssid) < 0) {
! 		wpa_printf(MSG_WARNING, "Could not read BSSID from driver.");
  		return NULL;
  	}
  
--- 1765,1771 ----
  	if (wpa_s->use_client_mlme)
  		os_memcpy(bssid, wpa_s->bssid, ETH_ALEN);
  	else if (wpa_drv_get_bssid(wpa_s, bssid) < 0) {
!         wpa_printf(MSG_WARNING, "Could not read BSSID from driver.");
  		return NULL;
  	}
  
***************
*** 1758,1763 ****
--- 1780,1803 ----
  		entry = entry->next;
  	}
  
+ #ifdef TI_WLAN_DRIVER
+ 	entry = wpa_s->conf->ssid;
+ 	while (entry) {
+ 		if (!entry->disabled &&
+ 		    entry->ssid_len == 0)
+ 			{
+ 				entry->ssid_len = ssid_len;
+                 entry->ssid = realloc(entry->ssid,ssid_len);
+                 if (entry->ssid == NULL) {
+                     wpa_printf(MSG_WARNING, "Could not realloc ssid entry.");
+                     return NULL;
+                 }
+ 				os_memcpy(entry->ssid, ssid, ssid_len);
+ 				return entry;
+ 			}	
+ 		entry = entry->next;
+ 	}
+ #endif
  	return NULL;
  }
  
diff -cr wpa_supplicant-0.5.7/wpa_supplicant.conf wpa_suppl/wpa_supplicant.conf
*** wpa_supplicant-0.5.7/wpa_supplicant.conf	2006-11-19 05:54:50.000000000 +0200
--- wpa_suppl/wpa_supplicant.conf	2007-11-07 16:18:02.000000000 +0200
***************
*** 1,734 ****
! ##### Example wpa_supplicant configuration file ###############################
! #
! # This file describes configuration file format and lists all available option.
! # Please also take a look at simpler configuration examples in 'examples'
! # subdirectory.
! #
! # Empty lines and lines starting with # are ignored
! 
! # NOTE! This file may contain password information and should probably be made
! # readable only by root user on multiuser systems.
! 
! # Note: All file paths in this configuration file should use full (absolute,
! # not relative to working directory) path in order to allow working directory
! # to be changed. This can happen if wpa_supplicant is run in the background.
! 
! # Whether to allow wpa_supplicant to update (overwrite) configuration
! #
! # This option can be used to allow wpa_supplicant to overwrite configuration
! # file whenever configuration is changed (e.g., new network block is added with
! # wpa_cli or wpa_gui, or a password is changed). This is required for
! # wpa_cli/wpa_gui to be able to store the configuration changes permanently.
! # Please note that overwriting configuration file will remove the comments from
! # it.
! #update_config=1
! 
! # global configuration (shared by all network blocks)
! #
! # Parameters for the control interface. If this is specified, wpa_supplicant
! # will open a control interface that is available for external programs to
! # manage wpa_supplicant. The meaning of this string depends on which control
! # interface mechanism is used. For all cases, the existance of this parameter
! # in configuration is used to determine whether the control interface is
! # enabled.
! #
! # For UNIX domain sockets (default on Linux and BSD): This is a directory that
! # will be created for UNIX domain sockets for listening to requests from
! # external programs (CLI/GUI, etc.) for status information and configuration.
! # The socket file will be named based on the interface name, so multiple
! # wpa_supplicant processes can be run at the same time if more than one
! # interface is used.
! # /var/run/wpa_supplicant is the recommended directory for sockets and by
! # default, wpa_cli will use it when trying to connect with wpa_supplicant.
! #
! # Access control for the control interface can be configured by setting the
! # directory to allow only members of a group to use sockets. This way, it is
! # possible to run wpa_supplicant as root (since it needs to change network
! # configuration and open raw sockets) and still allow GUI/CLI components to be
! # run as non-root users. However, since the control interface can be used to
! # change the network configuration, this access needs to be protected in many
! # cases. By default, wpa_supplicant is configured to use gid 0 (root). If you
! # want to allow non-root users to use the control interface, add a new group
! # and change this value to match with that group. Add users that should have
! # control interface access to this group. If this variable is commented out or
! # not included in the configuration file, group will not be changed from the
! # value it got by default when the directory or socket was created.
! #
! # When configuring both the directory and group, use following format:
! # DIR=/var/run/wpa_supplicant GROUP=wheel
! # DIR=/var/run/wpa_supplicant GROUP=0
! # (group can be either group name or gid)
! #
! # For UDP connections (default on Windows): The value will be ignored. This
! # variable is just used to select that the control interface is to be created.
! # The value can be set to, e.g., udp (ctrl_interface=udp)
! #
! # For Windows Named Pipe: This value can be used to set the security descriptor
! # for controlling access to the control interface. Security descriptor can be
! # set using Security Descriptor String Format (see http://msdn.microsoft.com/
! # library/default.asp?url=/library/en-us/secauthz/security/
! # security_descriptor_string_format.asp). The descriptor string needs to be
! # prefixed with SDDL=. For example, ctrl_interface=SDDL=D: would set an empty
! # DACL (which will reject all connections). See README-Windows.txt for more
! # information about SDDL string format.
! #
! ctrl_interface=/var/run/wpa_supplicant
! 
! # IEEE 802.1X/EAPOL version
! # wpa_supplicant is implemented based on IEEE Std 802.1X-2004 which defines
! # EAPOL version 2. However, there are many APs that do not handle the new
! # version number correctly (they seem to drop the frames completely). In order
! # to make wpa_supplicant interoperate with these APs, the version number is set
! # to 1 by default. This configuration value can be used to set it to the new
! # version (2).
! eapol_version=1
! 
! # AP scanning/selection
! # By default, wpa_supplicant requests driver to perform AP scanning and then
! # uses the scan results to select a suitable AP. Another alternative is to
! # allow the driver to take care of AP scanning and selection and use
! # wpa_supplicant just to process EAPOL frames based on IEEE 802.11 association
! # information from the driver.
! # 1: wpa_supplicant initiates scanning and AP selection
! # 0: driver takes care of scanning, AP selection, and IEEE 802.11 association
! #    parameters (e.g., WPA IE generation); this mode can also be used with
! #    non-WPA drivers when using IEEE 802.1X mode; do not try to associate with
! #    APs (i.e., external program needs to control association). This mode must
! #    also be used when using wired Ethernet drivers.
! # 2: like 0, but associate with APs using security policy and SSID (but not
! #    BSSID); this can be used, e.g., with ndiswrapper and NDIS drivers to
! #    enable operation with hidden SSIDs and optimized roaming; in this mode,
! #    the network blocks in the configuration file are tried one by one until
! #    the driver reports successful association; each network block should have
! #    explicit security policy (i.e., only one option in the lists) for
! #    key_mgmt, pairwise, group, proto variables
! ap_scan=1
! 
! # EAP fast re-authentication
! # By default, fast re-authentication is enabled for all EAP methods that
! # support it. This variable can be used to disable fast re-authentication.
! # Normally, there is no need to disable this.
! fast_reauth=1
! 
! # OpenSSL Engine support
! # These options can be used to load OpenSSL engines.
! # The two engines that are supported currently are shown below:
! # They are both from the opensc project (http://www.opensc.org/)
! # By default no engines are loaded.
! # make the opensc engine available
! #opensc_engine_path=/usr/lib/opensc/engine_opensc.so
! # make the pkcs11 engine available
! #pkcs11_engine_path=/usr/lib/opensc/engine_pkcs11.so
! # configure the path to the pkcs11 module required by the pkcs11 engine
! #pkcs11_module_path=/usr/lib/pkcs11/opensc-pkcs11.so
! 
! # Dynamic EAP methods
! # If EAP methods were built dynamically as shared object files, they need to be
! # loaded here before being used in the network blocks. By default, EAP methods
! # are included statically in the build, so these lines are not needed
! #load_dynamic_eap=/usr/lib/wpa_supplicant/eap_tls.so
! #load_dynamic_eap=/usr/lib/wpa_supplicant/eap_md5.so
! 
! # Driver interface parameters
! # This field can be used to configure arbitrary driver interace parameters. The
! # format is specific to the selected driver interface. This field is not used
! # in most cases.
! #driver_param="field=value"
! 
! # Maximum lifetime for PMKSA in seconds; default 43200
! #dot11RSNAConfigPMKLifetime=43200
! # Threshold for reauthentication (percentage of PMK lifetime); default 70
! #dot11RSNAConfigPMKReauthThreshold=70
! # Timeout for security association negotiation in seconds; default 60
! #dot11RSNAConfigSATimeout=60
! 
! # network block
! #
! # Each network (usually AP's sharing the same SSID) is configured as a separate
! # block in this configuration file. The network blocks are in preference order
! # (the first match is used).
! #
! # network block fields:
! #
! # disabled:
! #	0 = this network can be used (default)
! #	1 = this network block is disabled (can be enabled through ctrl_iface,
! #	    e.g., with wpa_cli or wpa_gui)
! #
! # id_str: Network identifier string for external scripts. This value is passed
! #	to external action script through wpa_cli as WPA_ID_STR environment
! #	variable to make it easier to do network specific configuration.
! #
! # ssid: SSID (mandatory); either as an ASCII string with double quotation or
! #	as hex string; network name
! #
! # scan_ssid:
! #	0 = do not scan this SSID with specific Probe Request frames (default)
! #	1 = scan with SSID-specific Probe Request frames (this can be used to
! #	    find APs that do not accept broadcast SSID or use multiple SSIDs;
! #	    this will add latency to scanning, so enable this only when needed)
! #
! # bssid: BSSID (optional); if set, this network block is used only when
! #	associating with the AP using the configured BSSID
! #
! # priority: priority group (integer)
! # By default, all networks will get same priority group (0). If some of the
! # networks are more desirable, this field can be used to change the order in
! # which wpa_supplicant goes through the networks when selecting a BSS. The
! # priority groups will be iterated in decreasing priority (i.e., the larger the
! # priority value, the sooner the network is matched against the scan results).
! # Within each priority group, networks will be selected based on security
! # policy, signal strength, etc.
! # Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are not
! # using this priority to select the order for scanning. Instead, they try the
! # networks in the order that used in the configuration file.
! #
! # mode: IEEE 802.11 operation mode
! # 0 = infrastructure (Managed) mode, i.e., associate with an AP (default)
! # 1 = IBSS (ad-hoc, peer-to-peer)
! # Note: IBSS can only be used with key_mgmt NONE (plaintext and static WEP)
! # and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In addition, ap_scan has
! # to be set to 2 for IBSS. WPA-None requires following network block options:
! # proto=WPA, key_mgmt=WPA-NONE, pairwise=NONE, group=TKIP (or CCMP, but not
! # both), and psk must also be set.
! #
! # proto: list of accepted protocols
! # WPA = WPA/IEEE 802.11i/D3.0
! # RSN = WPA2/IEEE 802.11i (also WPA2 can be used as an alias for RSN)
! # If not set, this defaults to: WPA RSN
! #
! # key_mgmt: list of accepted authenticated key management protocols
! # WPA-PSK = WPA pre-shared key (this requires 'psk' field)
! # WPA-EAP = WPA using EAP authentication (this can use an external
! #	program, e.g., Xsupplicant, for IEEE 802.1X EAP Authentication
! # IEEE8021X = IEEE 802.1X using EAP authentication and (optionally) dynamically
! #	generated WEP keys
! # NONE = WPA is not used; plaintext or static WEP could be used
! # If not set, this defaults to: WPA-PSK WPA-EAP
! #
! # auth_alg: list of allowed IEEE 802.11 authentication algorithms
! # OPEN = Open System authentication (required for WPA/WPA2)
! # SHARED = Shared Key authentication (requires static WEP keys)
! # LEAP = LEAP/Network EAP (only used with LEAP)
! # If not set, automatic selection is used (Open System with LEAP enabled if
! # LEAP is allowed as one of the EAP methods).
! #
! # pairwise: list of accepted pairwise (unicast) ciphers for WPA
! # CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
! # TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
! # NONE = Use only Group Keys (deprecated, should not be included if APs support
! #	pairwise keys)
! # If not set, this defaults to: CCMP TKIP
! #
! # group: list of accepted group (broadcast/multicast) ciphers for WPA
! # CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
! # TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
! # WEP104 = WEP (Wired Equivalent Privacy) with 104-bit key
! # WEP40 = WEP (Wired Equivalent Privacy) with 40-bit key [IEEE 802.11]
! # If not set, this defaults to: CCMP TKIP WEP104 WEP40
! #
! # psk: WPA preshared key; 256-bit pre-shared key
! # The key used in WPA-PSK mode can be entered either as 64 hex-digits, i.e.,
! # 32 bytes or as an ASCII passphrase (in which case, the real PSK will be
! # generated using the passphrase and SSID). ASCII passphrase must be between
! # 8 and 63 characters (inclusive).
! # This field is not needed, if WPA-EAP is used.
! # Note: Separate tool, wpa_passphrase, can be used to generate 256-bit keys
! # from ASCII passphrase. This process uses lot of CPU and wpa_supplicant
! # startup and reconfiguration time can be optimized by generating the PSK only
! # only when the passphrase or SSID has actually changed.
! #
! # eapol_flags: IEEE 802.1X/EAPOL options (bit field)
! # Dynamic WEP key required for non-WPA mode
! # bit0 (1): require dynamically generated unicast WEP key
! # bit1 (2): require dynamically generated broadcast WEP key
! # 	(3 = require both keys; default)
! # Note: When using wired authentication, eapol_flags must be set to 0 for the
! # authentication to be completed successfully.
! #
! # proactive_key_caching:
! # Enable/disable opportunistic PMKSA caching for WPA2.
! # 0 = disabled (default)
! # 1 = enabled
! #
! # wep_key0..3: Static WEP key (ASCII in double quotation, e.g. "abcde" or
! # hex without quotation, e.g., 0102030405)
! # wep_tx_keyidx: Default WEP key index (TX) (0..3)
! #
! # peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e DLS) is
! # allowed. This is only used with RSN/WPA2.
! # 0 = disabled (default)
! # 1 = enabled
! #peerkey=1
! #
! # Following fields are only used with internal EAP implementation.
! # eap: space-separated list of accepted EAP methods
! #	MD5 = EAP-MD5 (unsecure and does not generate keying material ->
! #			cannot be used with WPA; to be used as a Phase 2 method
! #			with EAP-PEAP or EAP-TTLS)
! #       MSCHAPV2 = EAP-MSCHAPv2 (cannot be used separately with WPA; to be used
! #		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
! #       OTP = EAP-OTP (cannot be used separately with WPA; to be used
! #		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
! #       GTC = EAP-GTC (cannot be used separately with WPA; to be used
! #		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
! #	TLS = EAP-TLS (client and server certificate)
! #	PEAP = EAP-PEAP (with tunnelled EAP authentication)
! #	TTLS = EAP-TTLS (with tunnelled EAP or PAP/CHAP/MSCHAP/MSCHAPV2
! #			 authentication)
! #	If not set, all compiled in methods are allowed.
! #
! # identity: Identity string for EAP
! # anonymous_identity: Anonymous identity string for EAP (to be used as the
! #	unencrypted identity with EAP types that support different tunnelled
! #	identity, e.g., EAP-TTLS)
! # password: Password string for EAP
! # ca_cert: File path to CA certificate file (PEM/DER). This file can have one
! #	or more trusted CA certificates. If ca_cert and ca_path are not
! #	included, server certificate will not be verified. This is insecure and
! #	a trusted CA certificate should always be configured when using
! #	EAP-TLS/TTLS/PEAP. Full path should be used since working directory may
! #	change when wpa_supplicant is run in the background.
! #	On Windows, trusted CA certificates can be loaded from the system
! #	certificate store by setting this to cert_store://<name>, e.g.,
! #	ca_cert="cert_store://CA" or ca_cert="cert_store://ROOT".
! #	Note that when running wpa_supplicant as an application, the user
! #	certificate store (My user account) is used, whereas computer store
! #	(Computer account) is used when running wpasvc as a service.
! # ca_path: Directory path for CA certificate files (PEM). This path may
! #	contain multiple CA certificates in OpenSSL format. Common use for this
! #	is to point to system trusted CA list which is often installed into
! #	directory like /etc/ssl/certs. If configured, these certificates are
! #	added to the list of trusted CAs. ca_cert may also be included in that
! #	case, but it is not required.
! # client_cert: File path to client certificate file (PEM/DER)
! #	Full path should be used since working directory may change when
! #	wpa_supplicant is run in the background.
! #	Alternatively, a named configuration blob can be used by setting this
! #	to blob://<blob name>.
! # private_key: File path to client private key file (PEM/DER/PFX)
! #	When PKCS#12/PFX file (.p12/.pfx) is used, client_cert should be
! #	commented out. Both the private key and certificate will be read from
! #	the PKCS#12 file in this case. Full path should be used since working
! #	directory may change when wpa_supplicant is run in the background.
! #	Windows certificate store can be used by leaving client_cert out and
! #	configuring private_key in one of the following formats:
! #	cert://substring_to_match
! #	hash://certificate_thumbprint_in_hex
! #	for example: private_key="hash://63093aa9c47f56ae88334c7b65a4"
! #	Note that when running wpa_supplicant as an application, the user
! #	certificate store (My user account) is used, whereas computer store
! #	(Computer account) is used when running wpasvc as a service.
! #	Alternatively, a named configuration blob can be used by setting this
! #	to blob://<blob name>.
! # private_key_passwd: Password for private key file (if left out, this will be
! #	asked through control interface)
! # dh_file: File path to DH/DSA parameters file (in PEM format)
! #	This is an optional configuration file for setting parameters for an
! #	ephemeral DH key exchange. In most cases, the default RSA
! #	authentication does not use this configuration. However, it is possible
! #	setup RSA to use ephemeral DH key exchange. In addition, ciphers with
! #	DSA keys always use ephemeral DH keys. This can be used to achieve
! #	forward secrecy. If the file is in DSA parameters format, it will be
! #	automatically converted into DH params.
! # subject_match: Substring to be matched against the subject of the
! #	authentication server certificate. If this string is set, the server
! #	sertificate is only accepted if it contains this string in the subject.
! #	The subject string is in following format:
! #	/C=US/ST=CA/L=San Francisco/CN=Test AS/emailAddress=as@example.com
! # altsubject_match: Semicolon separated string of entries to be matched against
! #	the alternative subject name of the authentication server certificate.
! #	If this string is set, the server sertificate is only accepted if it
! #	contains one of the entries in an alternative subject name extension.
! #	altSubjectName string is in following format: TYPE:VALUE
! #	Example: EMAIL:server@example.com
! #	Example: DNS:server.example.com;DNS:server2.example.com
! #	Following types are supported: EMAIL, DNS, URI
! # phase1: Phase1 (outer authentication, i.e., TLS tunnel) parameters
! #	(string with field-value pairs, e.g., "peapver=0" or
! #	"peapver=1 peaplabel=1")
! #	'peapver' can be used to force which PEAP version (0 or 1) is used.
! #	'peaplabel=1' can be used to force new label, "client PEAP encryption",
! #	to be used during key derivation when PEAPv1 or newer. Most existing
! #	PEAPv1 implementation seem to be using the old label, "client EAP
! #	encryption", and wpa_supplicant is now using that as the default value.
! #	Some servers, e.g., Radiator, may require peaplabel=1 configuration to
! #	interoperate with PEAPv1; see eap_testing.txt for more details.
! #	'peap_outer_success=0' can be used to terminate PEAP authentication on
! #	tunneled EAP-Success. This is required with some RADIUS servers that
! #	implement draft-josefsson-pppext-eap-tls-eap-05.txt (e.g.,
! #	Lucent NavisRadius v4.4.0 with PEAP in "IETF Draft 5" mode)
! #	include_tls_length=1 can be used to force wpa_supplicant to include
! #	TLS Message Length field in all TLS messages even if they are not
! #	fragmented.
! #	sim_min_num_chal=3 can be used to configure EAP-SIM to require three
! #	challenges (by default, it accepts 2 or 3)
! # phase2: Phase2 (inner authentication with TLS tunnel) parameters
! #	(string with field-value pairs, e.g., "auth=MSCHAPV2" for EAP-PEAP or
! #	"autheap=MSCHAPV2 autheap=MD5" for EAP-TTLS)
! # Following certificate/private key fields are used in inner Phase2
! # authentication when using EAP-TTLS or EAP-PEAP.
! # ca_cert2: File path to CA certificate file. This file can have one or more
! #	trusted CA certificates. If ca_cert2 and ca_path2 are not included,
! #	server certificate will not be verified. This is insecure and a trusted
! #	CA certificate should always be configured.
! # ca_path2: Directory path for CA certificate files (PEM)
! # client_cert2: File path to client certificate file
! # private_key2: File path to client private key file
! # private_key2_passwd: Password for private key file
! # dh_file2: File path to DH/DSA parameters file (in PEM format)
! # subject_match2: Substring to be matched against the subject of the
! #	authentication server certificate.
! # altsubject_match2: Substring to be matched against the alternative subject
! #	name of the authentication server certificate.
! #
! # fragment_size: Maximum EAP fragment size in bytes (default 1398).
! #	This value limits the fragment size for EAP methods that support
! #	fragmentation (e.g., EAP-TLS and EAP-PEAP). This value should be set
! #	small enough to make the EAP messages fit in MTU of the network
! #	interface used for EAPOL. The default value is suitable for most
! #	cases.
! #
! # EAP-PSK variables:
! # eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
! # nai: user NAI
! #
! # EAP-PAX variables:
! # eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
! #
! # EAP-SAKE variables:
! # eappsk: 32-byte (256-bit, 64 hex digits) pre-shared key in hex format
! #	(this is concatenation of Root-Secret-A and Root-Secret-B)
! # nai: user NAI (PEERID)
! #
! # EAP-GPSK variables:
! # eappsk: Pre-shared key in hex format (at least 128 bits, i.e., 32 hex digits)
! # nai: user NAI (ID_Client)
! #
! # EAP-FAST variables:
! # pac_file: File path for the PAC entries. wpa_supplicant will need to be able
! #	to create this file and write updates to it when PAC is being
! #	provisioned or refreshed. Full path to the file should be used since
! #	working directory may change when wpa_supplicant is run in the
! #	background. Alternatively, a named configuration blob can be used by
! #	setting this to blob://<blob name>
! # phase1: fast_provisioning=1 option enables in-line provisioning of EAP-FAST
! #	credentials (PAC)
! #
! # wpa_supplicant supports number of "EAP workarounds" to work around
! # interoperability issues with incorrectly behaving authentication servers.
! # These are enabled by default because some of the issues are present in large
! # number of authentication servers. Strict EAP conformance mode can be
! # configured by disabling workarounds with eap_workaround=0.
! 
! # Example blocks:
! 
! # Simple case: WPA-PSK, PSK as an ASCII passphrase, allow all valid ciphers
! network={
! 	ssid="simple"
! 	psk="very secret passphrase"
! 	priority=5
! }
! 
! # Same as previous, but request SSID-specific scanning (for APs that reject
! # broadcast SSID)
! network={
! 	ssid="second ssid"
! 	scan_ssid=1
! 	psk="very secret passphrase"
! 	priority=2
! }
! 
! # Only WPA-PSK is used. Any valid cipher combination is accepted.
! network={
! 	ssid="example"
! 	proto=WPA
! 	key_mgmt=WPA-PSK
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP WEP104 WEP40
! 	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
! 	priority=2
! }
! 
! # Only WPA-EAP is used. Both CCMP and TKIP is accepted. An AP that used WEP104
! # or WEP40 as the group cipher will not be accepted.
! network={
! 	ssid="example"
! 	proto=RSN
! 	key_mgmt=WPA-EAP
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP
! 	eap=TLS
! 	identity="user@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 	private_key="/etc/cert/user.prv"
! 	private_key_passwd="password"
! 	priority=1
! }
! 
! # EAP-PEAP/MSCHAPv2 configuration for RADIUS servers that use the new peaplabel
! # (e.g., Radiator)
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=PEAP
! 	identity="user@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	phase1="peaplabel=1"
! 	phase2="auth=MSCHAPV2"
! 	priority=10
! }
! 
! # EAP-TTLS/EAP-MD5-Challenge configuration with anonymous identity for the
! # unencrypted use. Real identity is sent only within an encrypted TLS tunnel.
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	identity="user@example.com"
! 	anonymous_identity="anonymous@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	priority=2
! }
! 
! # EAP-TTLS/MSCHAPv2 configuration with anonymous identity for the unencrypted
! # use. Real identity is sent only within an encrypted TLS tunnel.
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	identity="user@example.com"
! 	anonymous_identity="anonymous@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	phase2="auth=MSCHAPV2"
! }
! 
! # WPA-EAP, EAP-TTLS with different CA certificate used for outer and inner
! # authentication.
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	# Phase1 / outer authentication
! 	anonymous_identity="anonymous@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	# Phase 2 / inner authentication
! 	phase2="autheap=TLS"
! 	ca_cert2="/etc/cert/ca2.pem"
! 	client_cert2="/etc/cer/user.pem"
! 	private_key2="/etc/cer/user.prv"
! 	private_key2_passwd="password"
! 	priority=2
! }
! 
! # Both WPA-PSK and WPA-EAP is accepted. Only CCMP is accepted as pairwise and
! # group cipher.
! network={
! 	ssid="example"
! 	bssid=00:11:22:33:44:55
! 	proto=WPA RSN
! 	key_mgmt=WPA-PSK WPA-EAP
! 	pairwise=CCMP
! 	group=CCMP
! 	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
! }
! 
! # Special characters in SSID, so use hex string. Default to WPA-PSK, WPA-EAP
! # and all valid ciphers.
! network={
! 	ssid=00010203
! 	psk=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
! }
! 
! 
! # EAP-SIM with a GSM SIM or USIM
! network={
! 	ssid="eap-sim-test"
! 	key_mgmt=WPA-EAP
! 	eap=SIM
! 	pin="1234"
! 	pcsc=""
! }
! 
! 
! # EAP-PSK
! network={
! 	ssid="eap-psk-test"
! 	key_mgmt=WPA-EAP
! 	eap=PSK
! 	identity="eap_psk_user"
! 	eappsk=06b4be19da289f475aa46a33cb793029
! 	nai="eap_psk_user@example.com"
! }
! 
! 
! # IEEE 802.1X/EAPOL with dynamically generated WEP keys (i.e., no WPA) using
! # EAP-TLS for authentication and key generation; require both unicast and
! # broadcast WEP keys.
! network={
! 	ssid="1x-test"
! 	key_mgmt=IEEE8021X
! 	eap=TLS
! 	identity="user@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 	private_key="/etc/cert/user.prv"
! 	private_key_passwd="password"
! 	eapol_flags=3
! }
! 
! 
! # LEAP with dynamic WEP keys
! network={
! 	ssid="leap-example"
! 	key_mgmt=IEEE8021X
! 	eap=LEAP
! 	identity="user"
! 	password="foobar"
! }
! 
! # EAP-FAST with WPA (WPA or WPA2)
! network={
! 	ssid="eap-fast-test"
! 	key_mgmt=WPA-EAP
! 	eap=FAST
! 	anonymous_identity="FAST-000102030405"
! 	identity="username"
! 	password="password"
! 	phase1="fast_provisioning=1"
! 	pac_file="/etc/wpa_supplicant.eap-fast-pac"
! }
! 
! network={
! 	ssid="eap-fast-test"
! 	key_mgmt=WPA-EAP
! 	eap=FAST
! 	anonymous_identity="FAST-000102030405"
! 	identity="username"
! 	password="password"
! 	phase1="fast_provisioning=1"
! 	pac_file="blob://eap-fast-pac"
! }
! 
! # Plaintext connection (no WPA, no IEEE 802.1X)
! network={
! 	ssid="plaintext-test"
! 	key_mgmt=NONE
! }
! 
! 
! # Shared WEP key connection (no WPA, no IEEE 802.1X)
! network={
! 	ssid="static-wep-test"
! 	key_mgmt=NONE
! 	wep_key0="abcde"
! 	wep_key1=0102030405
! 	wep_key2="1234567890123"
! 	wep_tx_keyidx=0
! 	priority=5
! }
! 
! 
! # Shared WEP key connection (no WPA, no IEEE 802.1X) using Shared Key
! # IEEE 802.11 authentication
! network={
! 	ssid="static-wep-test2"
! 	key_mgmt=NONE
! 	wep_key0="abcde"
! 	wep_key1=0102030405
! 	wep_key2="1234567890123"
! 	wep_tx_keyidx=0
! 	priority=5
! 	auth_alg=SHARED
! }
! 
! 
! # IBSS/ad-hoc network with WPA-None/TKIP.
! network={
! 	ssid="test adhoc"
! 	mode=1
! 	proto=WPA
! 	key_mgmt=WPA-NONE
! 	pairwise=NONE
! 	group=TKIP
! 	psk="secret passphrase"
! }
! 
! 
! # Catch all example that allows more or less all configuration modes
! network={
! 	ssid="example"
! 	scan_ssid=1
! 	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP WEP104 WEP40
! 	psk="very secret passphrase"
! 	eap=TTLS PEAP TLS
! 	identity="user@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 	private_key="/etc/cert/user.prv"
! 	private_key_passwd="password"
! 	phase1="peaplabel=0"
! }
! 
! # Example of EAP-TLS with smartcard (openssl engine)
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TLS
! 	proto=RSN
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP
! 	identity="user@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 
! 	engine=1
! 
! 	# The engine configured here must be available. Look at
! 	# OpenSSL engine support in the global section.
! 	# The key available through the engine must be the private key
! 	# matching the client certificate configured above.
! 
! 	# use the opensc engine
! 	#engine_id="opensc"
! 	#key_id="45"
! 
! 	# use the pkcs11 engine
! 	engine_id="pkcs11"
! 	key_id="id_45"
! 
! 	# Optional PIN configuration; this can be left out and PIN will be
! 	# asked through the control interface
! 	pin="1234"
! }
! 
! # Example configuration showing how to use an inlined blob as a CA certificate
! # data instead of using external file
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	identity="user@example.com"
! 	anonymous_identity="anonymous@example.com"
! 	password="foobar"
! 	ca_cert="blob://exampleblob"
! 	priority=20
! }
! 
! blob-base64-exampleblob={
! SGVsbG8gV29ybGQhCg==
! }
! 
! 
! # Wildcard match for SSID (plaintext APs only). This example select any
! # open AP regardless of its SSID.
! network={
! 	key_mgmt=NONE
! }
--- 1,734 ----
! ##### Example wpa_supplicant configuration file ###############################
! #
! # This file describes configuration file format and lists all available option.
! # Please also take a look at simpler configuration examples in 'examples'
! # subdirectory.
! #
! # Empty lines and lines starting with # are ignored
! 
! # NOTE! This file may contain password information and should probably be made
! # readable only by root user on multiuser systems.
! 
! # Note: All file paths in this configuration file should use full (absolute,
! # not relative to working directory) path in order to allow working directory
! # to be changed. This can happen if wpa_supplicant is run in the background.
! 
! # Whether to allow wpa_supplicant to update (overwrite) configuration
! #
! # This option can be used to allow wpa_supplicant to overwrite configuration
! # file whenever configuration is changed (e.g., new network block is added with
! # wpa_cli or wpa_gui, or a password is changed). This is required for
! # wpa_cli/wpa_gui to be able to store the configuration changes permanently.
! # Please note that overwriting configuration file will remove the comments from
! # it.
! #update_config=1
! 
! # global configuration (shared by all network blocks)
! #
! # Parameters for the control interface. If this is specified, wpa_supplicant
! # will open a control interface that is available for external programs to
! # manage wpa_supplicant. The meaning of this string depends on which control
! # interface mechanism is used. For all cases, the existance of this parameter
! # in configuration is used to determine whether the control interface is
! # enabled.
! #
! # For UNIX domain sockets (default on Linux and BSD): This is a directory that
! # will be created for UNIX domain sockets for listening to requests from
! # external programs (CLI/GUI, etc.) for status information and configuration.
! # The socket file will be named based on the interface name, so multiple
! # wpa_supplicant processes can be run at the same time if more than one
! # interface is used.
! # /var/run/wpa_supplicant is the recommended directory for sockets and by
! # default, wpa_cli will use it when trying to connect with wpa_supplicant.
! #
! # Access control for the control interface can be configured by setting the
! # directory to allow only members of a group to use sockets. This way, it is
! # possible to run wpa_supplicant as root (since it needs to change network
! # configuration and open raw sockets) and still allow GUI/CLI components to be
! # run as non-root users. However, since the control interface can be used to
! # change the network configuration, this access needs to be protected in many
! # cases. By default, wpa_supplicant is configured to use gid 0 (root). If you
! # want to allow non-root users to use the control interface, add a new group
! # and change this value to match with that group. Add users that should have
! # control interface access to this group. If this variable is commented out or
! # not included in the configuration file, group will not be changed from the
! # value it got by default when the directory or socket was created.
! #
! # When configuring both the directory and group, use following format:
! # DIR=/var/run/wpa_supplicant GROUP=wheel
! # DIR=/var/run/wpa_supplicant GROUP=0
! # (group can be either group name or gid)
! #
! # For UDP connections (default on Windows): The value will be ignored. This
! # variable is just used to select that the control interface is to be created.
! # The value can be set to, e.g., udp (ctrl_interface=udp)
! #
! # For Windows Named Pipe: This value can be used to set the security descriptor
! # for controlling access to the control interface. Security descriptor can be
! # set using Security Descriptor String Format (see http://msdn.microsoft.com/
! # library/default.asp?url=/library/en-us/secauthz/security/
! # security_descriptor_string_format.asp). The descriptor string needs to be
! # prefixed with SDDL=. For example, ctrl_interface=SDDL=D: would set an empty
! # DACL (which will reject all connections). See README-Windows.txt for more
! # information about SDDL string format.
! #
! ctrl_interface=/var/run/wpa_supplicant
! 
! # IEEE 802.1X/EAPOL version
! # wpa_supplicant is implemented based on IEEE Std 802.1X-2004 which defines
! # EAPOL version 2. However, there are many APs that do not handle the new
! # version number correctly (they seem to drop the frames completely). In order
! # to make wpa_supplicant interoperate with these APs, the version number is set
! # to 1 by default. This configuration value can be used to set it to the new
! # version (2).
! eapol_version=1
! 
! # AP scanning/selection
! # By default, wpa_supplicant requests driver to perform AP scanning and then
! # uses the scan results to select a suitable AP. Another alternative is to
! # allow the driver to take care of AP scanning and selection and use
! # wpa_supplicant just to process EAPOL frames based on IEEE 802.11 association
! # information from the driver.
! # 1: wpa_supplicant initiates scanning and AP selection
! # 0: driver takes care of scanning, AP selection, and IEEE 802.11 association
! #    parameters (e.g., WPA IE generation); this mode can also be used with
! #    non-WPA drivers when using IEEE 802.1X mode; do not try to associate with
! #    APs (i.e., external program needs to control association). This mode must
! #    also be used when using wired Ethernet drivers.
! # 2: like 0, but associate with APs using security policy and SSID (but not
! #    BSSID); this can be used, e.g., with ndiswrapper and NDIS drivers to
! #    enable operation with hidden SSIDs and optimized roaming; in this mode,
! #    the network blocks in the configuration file are tried one by one until
! #    the driver reports successful association; each network block should have
! #    explicit security policy (i.e., only one option in the lists) for
! #    key_mgmt, pairwise, group, proto variables
! ap_scan=1
! 
! # EAP fast re-authentication
! # By default, fast re-authentication is enabled for all EAP methods that
! # support it. This variable can be used to disable fast re-authentication.
! # Normally, there is no need to disable this.
! fast_reauth=1
! 
! # OpenSSL Engine support
! # These options can be used to load OpenSSL engines.
! # The two engines that are supported currently are shown below:
! # They are both from the opensc project (http://www.opensc.org/)
! # By default no engines are loaded.
! # make the opensc engine available
! #opensc_engine_path=/usr/lib/opensc/engine_opensc.so
! # make the pkcs11 engine available
! #pkcs11_engine_path=/usr/lib/opensc/engine_pkcs11.so
! # configure the path to the pkcs11 module required by the pkcs11 engine
! #pkcs11_module_path=/usr/lib/pkcs11/opensc-pkcs11.so
! 
! # Dynamic EAP methods
! # If EAP methods were built dynamically as shared object files, they need to be
! # loaded here before being used in the network blocks. By default, EAP methods
! # are included statically in the build, so these lines are not needed
! #load_dynamic_eap=/usr/lib/wpa_supplicant/eap_tls.so
! #load_dynamic_eap=/usr/lib/wpa_supplicant/eap_md5.so
! 
! # Driver interface parameters
! # This field can be used to configure arbitrary driver interace parameters. The
! # format is specific to the selected driver interface. This field is not used
! # in most cases.
! #driver_param="field=value"
! 
! # Maximum lifetime for PMKSA in seconds; default 43200
! #dot11RSNAConfigPMKLifetime=43200
! # Threshold for reauthentication (percentage of PMK lifetime); default 70
! #dot11RSNAConfigPMKReauthThreshold=70
! # Timeout for security association negotiation in seconds; default 60
! #dot11RSNAConfigSATimeout=60
! 
! # network block
! #
! # Each network (usually AP's sharing the same SSID) is configured as a separate
! # block in this configuration file. The network blocks are in preference order
! # (the first match is used).
! #
! # network block fields:
! #
! # disabled:
! #	0 = this network can be used (default)
! #	1 = this network block is disabled (can be enabled through ctrl_iface,
! #	    e.g., with wpa_cli or wpa_gui)
! #
! # id_str: Network identifier string for external scripts. This value is passed
! #	to external action script through wpa_cli as WPA_ID_STR environment
! #	variable to make it easier to do network specific configuration.
! #
! # ssid: SSID (mandatory); either as an ASCII string with double quotation or
! #	as hex string; network name
! #
! # scan_ssid:
! #	0 = do not scan this SSID with specific Probe Request frames (default)
! #	1 = scan with SSID-specific Probe Request frames (this can be used to
! #	    find APs that do not accept broadcast SSID or use multiple SSIDs;
! #	    this will add latency to scanning, so enable this only when needed)
! #
! # bssid: BSSID (optional); if set, this network block is used only when
! #	associating with the AP using the configured BSSID
! #
! # priority: priority group (integer)
! # By default, all networks will get same priority group (0). If some of the
! # networks are more desirable, this field can be used to change the order in
! # which wpa_supplicant goes through the networks when selecting a BSS. The
! # priority groups will be iterated in decreasing priority (i.e., the larger the
! # priority value, the sooner the network is matched against the scan results).
! # Within each priority group, networks will be selected based on security
! # policy, signal strength, etc.
! # Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are not
! # using this priority to select the order for scanning. Instead, they try the
! # networks in the order that used in the configuration file.
! #
! # mode: IEEE 802.11 operation mode
! # 0 = infrastructure (Managed) mode, i.e., associate with an AP (default)
! # 1 = IBSS (ad-hoc, peer-to-peer)
! # Note: IBSS can only be used with key_mgmt NONE (plaintext and static WEP)
! # and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In addition, ap_scan has
! # to be set to 2 for IBSS. WPA-None requires following network block options:
! # proto=WPA, key_mgmt=WPA-NONE, pairwise=NONE, group=TKIP (or CCMP, but not
! # both), and psk must also be set.
! #
! # proto: list of accepted protocols
! # WPA = WPA/IEEE 802.11i/D3.0
! # RSN = WPA2/IEEE 802.11i (also WPA2 can be used as an alias for RSN)
! # If not set, this defaults to: WPA RSN
! #
! # key_mgmt: list of accepted authenticated key management protocols
! # WPA-PSK = WPA pre-shared key (this requires 'psk' field)
! # WPA-EAP = WPA using EAP authentication (this can use an external
! #	program, e.g., Xsupplicant, for IEEE 802.1X EAP Authentication
! # IEEE8021X = IEEE 802.1X using EAP authentication and (optionally) dynamically
! #	generated WEP keys
! # NONE = WPA is not used; plaintext or static WEP could be used
! # If not set, this defaults to: WPA-PSK WPA-EAP
! #
! # auth_alg: list of allowed IEEE 802.11 authentication algorithms
! # OPEN = Open System authentication (required for WPA/WPA2)
! # SHARED = Shared Key authentication (requires static WEP keys)
! # LEAP = LEAP/Network EAP (only used with LEAP)
! # If not set, automatic selection is used (Open System with LEAP enabled if
! # LEAP is allowed as one of the EAP methods).
! #
! # pairwise: list of accepted pairwise (unicast) ciphers for WPA
! # CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
! # TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
! # NONE = Use only Group Keys (deprecated, should not be included if APs support
! #	pairwise keys)
! # If not set, this defaults to: CCMP TKIP
! #
! # group: list of accepted group (broadcast/multicast) ciphers for WPA
! # CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
! # TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
! # WEP104 = WEP (Wired Equivalent Privacy) with 104-bit key
! # WEP40 = WEP (Wired Equivalent Privacy) with 40-bit key [IEEE 802.11]
! # If not set, this defaults to: CCMP TKIP WEP104 WEP40
! #
! # psk: WPA preshared key; 256-bit pre-shared key
! # The key used in WPA-PSK mode can be entered either as 64 hex-digits, i.e.,
! # 32 bytes or as an ASCII passphrase (in which case, the real PSK will be
! # generated using the passphrase and SSID). ASCII passphrase must be between
! # 8 and 63 characters (inclusive).
! # This field is not needed, if WPA-EAP is used.
! # Note: Separate tool, wpa_passphrase, can be used to generate 256-bit keys
! # from ASCII passphrase. This process uses lot of CPU and wpa_supplicant
! # startup and reconfiguration time can be optimized by generating the PSK only
! # only when the passphrase or SSID has actually changed.
! #
! # eapol_flags: IEEE 802.1X/EAPOL options (bit field)
! # Dynamic WEP key required for non-WPA mode
! # bit0 (1): require dynamically generated unicast WEP key
! # bit1 (2): require dynamically generated broadcast WEP key
! # 	(3 = require both keys; default)
! # Note: When using wired authentication, eapol_flags must be set to 0 for the
! # authentication to be completed successfully.
! #
! # proactive_key_caching:
! # Enable/disable opportunistic PMKSA caching for WPA2.
! # 0 = disabled (default)
! # 1 = enabled
! #
! # wep_key0..3: Static WEP key (ASCII in double quotation, e.g. "abcde" or
! # hex without quotation, e.g., 0102030405)
! # wep_tx_keyidx: Default WEP key index (TX) (0..3)
! #
! # peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e DLS) is
! # allowed. This is only used with RSN/WPA2.
! # 0 = disabled (default)
! # 1 = enabled
! #peerkey=1
! #
! # Following fields are only used with internal EAP implementation.
! # eap: space-separated list of accepted EAP methods
! #	MD5 = EAP-MD5 (unsecure and does not generate keying material ->
! #			cannot be used with WPA; to be used as a Phase 2 method
! #			with EAP-PEAP or EAP-TTLS)
! #       MSCHAPV2 = EAP-MSCHAPv2 (cannot be used separately with WPA; to be used
! #		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
! #       OTP = EAP-OTP (cannot be used separately with WPA; to be used
! #		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
! #       GTC = EAP-GTC (cannot be used separately with WPA; to be used
! #		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
! #	TLS = EAP-TLS (client and server certificate)
! #	PEAP = EAP-PEAP (with tunnelled EAP authentication)
! #	TTLS = EAP-TTLS (with tunnelled EAP or PAP/CHAP/MSCHAP/MSCHAPV2
! #			 authentication)
! #	If not set, all compiled in methods are allowed.
! #
! # identity: Identity string for EAP
! # anonymous_identity: Anonymous identity string for EAP (to be used as the
! #	unencrypted identity with EAP types that support different tunnelled
! #	identity, e.g., EAP-TTLS)
! # password: Password string for EAP
! # ca_cert: File path to CA certificate file (PEM/DER). This file can have one
! #	or more trusted CA certificates. If ca_cert and ca_path are not
! #	included, server certificate will not be verified. This is insecure and
! #	a trusted CA certificate should always be configured when using
! #	EAP-TLS/TTLS/PEAP. Full path should be used since working directory may
! #	change when wpa_supplicant is run in the background.
! #	On Windows, trusted CA certificates can be loaded from the system
! #	certificate store by setting this to cert_store://<name>, e.g.,
! #	ca_cert="cert_store://CA" or ca_cert="cert_store://ROOT".
! #	Note that when running wpa_supplicant as an application, the user
! #	certificate store (My user account) is used, whereas computer store
! #	(Computer account) is used when running wpasvc as a service.
! # ca_path: Directory path for CA certificate files (PEM). This path may
! #	contain multiple CA certificates in OpenSSL format. Common use for this
! #	is to point to system trusted CA list which is often installed into
! #	directory like /etc/ssl/certs. If configured, these certificates are
! #	added to the list of trusted CAs. ca_cert may also be included in that
! #	case, but it is not required.
! # client_cert: File path to client certificate file (PEM/DER)
! #	Full path should be used since working directory may change when
! #	wpa_supplicant is run in the background.
! #	Alternatively, a named configuration blob can be used by setting this
! #	to blob://<blob name>.
! # private_key: File path to client private key file (PEM/DER/PFX)
! #	When PKCS#12/PFX file (.p12/.pfx) is used, client_cert should be
! #	commented out. Both the private key and certificate will be read from
! #	the PKCS#12 file in this case. Full path should be used since working
! #	directory may change when wpa_supplicant is run in the background.
! #	Windows certificate store can be used by leaving client_cert out and
! #	configuring private_key in one of the following formats:
! #	cert://substring_to_match
! #	hash://certificate_thumbprint_in_hex
! #	for example: private_key="hash://63093aa9c47f56ae88334c7b65a4"
! #	Note that when running wpa_supplicant as an application, the user
! #	certificate store (My user account) is used, whereas computer store
! #	(Computer account) is used when running wpasvc as a service.
! #	Alternatively, a named configuration blob can be used by setting this
! #	to blob://<blob name>.
! # private_key_passwd: Password for private key file (if left out, this will be
! #	asked through control interface)
! # dh_file: File path to DH/DSA parameters file (in PEM format)
! #	This is an optional configuration file for setting parameters for an
! #	ephemeral DH key exchange. In most cases, the default RSA
! #	authentication does not use this configuration. However, it is possible
! #	setup RSA to use ephemeral DH key exchange. In addition, ciphers with
! #	DSA keys always use ephemeral DH keys. This can be used to achieve
! #	forward secrecy. If the file is in DSA parameters format, it will be
! #	automatically converted into DH params.
! # subject_match: Substring to be matched against the subject of the
! #	authentication server certificate. If this string is set, the server
! #	sertificate is only accepted if it contains this string in the subject.
! #	The subject string is in following format:
! #	/C=US/ST=CA/L=San Francisco/CN=Test AS/emailAddress=as@example.com
! # altsubject_match: Semicolon separated string of entries to be matched against
! #	the alternative subject name of the authentication server certificate.
! #	If this string is set, the server sertificate is only accepted if it
! #	contains one of the entries in an alternative subject name extension.
! #	altSubjectName string is in following format: TYPE:VALUE
! #	Example: EMAIL:server@example.com
! #	Example: DNS:server.example.com;DNS:server2.example.com
! #	Following types are supported: EMAIL, DNS, URI
! # phase1: Phase1 (outer authentication, i.e., TLS tunnel) parameters
! #	(string with field-value pairs, e.g., "peapver=0" or
! #	"peapver=1 peaplabel=1")
! #	'peapver' can be used to force which PEAP version (0 or 1) is used.
! #	'peaplabel=1' can be used to force new label, "client PEAP encryption",
! #	to be used during key derivation when PEAPv1 or newer. Most existing
! #	PEAPv1 implementation seem to be using the old label, "client EAP
! #	encryption", and wpa_supplicant is now using that as the default value.
! #	Some servers, e.g., Radiator, may require peaplabel=1 configuration to
! #	interoperate with PEAPv1; see eap_testing.txt for more details.
! #	'peap_outer_success=0' can be used to terminate PEAP authentication on
! #	tunneled EAP-Success. This is required with some RADIUS servers that
! #	implement draft-josefsson-pppext-eap-tls-eap-05.txt (e.g.,
! #	Lucent NavisRadius v4.4.0 with PEAP in "IETF Draft 5" mode)
! #	include_tls_length=1 can be used to force wpa_supplicant to include
! #	TLS Message Length field in all TLS messages even if they are not
! #	fragmented.
! #	sim_min_num_chal=3 can be used to configure EAP-SIM to require three
! #	challenges (by default, it accepts 2 or 3)
! # phase2: Phase2 (inner authentication with TLS tunnel) parameters
! #	(string with field-value pairs, e.g., "auth=MSCHAPV2" for EAP-PEAP or
! #	"autheap=MSCHAPV2 autheap=MD5" for EAP-TTLS)
! # Following certificate/private key fields are used in inner Phase2
! # authentication when using EAP-TTLS or EAP-PEAP.
! # ca_cert2: File path to CA certificate file. This file can have one or more
! #	trusted CA certificates. If ca_cert2 and ca_path2 are not included,
! #	server certificate will not be verified. This is insecure and a trusted
! #	CA certificate should always be configured.
! # ca_path2: Directory path for CA certificate files (PEM)
! # client_cert2: File path to client certificate file
! # private_key2: File path to client private key file
! # private_key2_passwd: Password for private key file
! # dh_file2: File path to DH/DSA parameters file (in PEM format)
! # subject_match2: Substring to be matched against the subject of the
! #	authentication server certificate.
! # altsubject_match2: Substring to be matched against the alternative subject
! #	name of the authentication server certificate.
! #
! # fragment_size: Maximum EAP fragment size in bytes (default 1398).
! #	This value limits the fragment size for EAP methods that support
! #	fragmentation (e.g., EAP-TLS and EAP-PEAP). This value should be set
! #	small enough to make the EAP messages fit in MTU of the network
! #	interface used for EAPOL. The default value is suitable for most
! #	cases.
! #
! # EAP-PSK variables:
! # eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
! # nai: user NAI
! #
! # EAP-PAX variables:
! # eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
! #
! # EAP-SAKE variables:
! # eappsk: 32-byte (256-bit, 64 hex digits) pre-shared key in hex format
! #	(this is concatenation of Root-Secret-A and Root-Secret-B)
! # nai: user NAI (PEERID)
! #
! # EAP-GPSK variables:
! # eappsk: Pre-shared key in hex format (at least 128 bits, i.e., 32 hex digits)
! # nai: user NAI (ID_Client)
! #
! # EAP-FAST variables:
! # pac_file: File path for the PAC entries. wpa_supplicant will need to be able
! #	to create this file and write updates to it when PAC is being
! #	provisioned or refreshed. Full path to the file should be used since
! #	working directory may change when wpa_supplicant is run in the
! #	background. Alternatively, a named configuration blob can be used by
! #	setting this to blob://<blob name>
! # phase1: fast_provisioning=1 option enables in-line provisioning of EAP-FAST
! #	credentials (PAC)
! #
! # wpa_supplicant supports number of "EAP workarounds" to work around
! # interoperability issues with incorrectly behaving authentication servers.
! # These are enabled by default because some of the issues are present in large
! # number of authentication servers. Strict EAP conformance mode can be
! # configured by disabling workarounds with eap_workaround=0.
! 
! # Example blocks:
! 
! # Simple case: WPA-PSK, PSK as an ASCII passphrase, allow all valid ciphers
! network={
! 	ssid="simple"
! 	psk="very secret passphrase"
! 	priority=5
! }
! 
! # Same as previous, but request SSID-specific scanning (for APs that reject
! # broadcast SSID)
! network={
! 	ssid="second ssid"
! 	scan_ssid=1
! 	psk="very secret passphrase"
! 	priority=2
! }
! 
! # Only WPA-PSK is used. Any valid cipher combination is accepted.
! network={
! 	ssid="example"
! 	proto=WPA
! 	key_mgmt=WPA-PSK
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP WEP104 WEP40
! 	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
! 	priority=2
! }
! 
! # Only WPA-EAP is used. Both CCMP and TKIP is accepted. An AP that used WEP104
! # or WEP40 as the group cipher will not be accepted.
! network={
! 	ssid="example"
! 	proto=RSN
! 	key_mgmt=WPA-EAP
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP
! 	eap=TLS
! 	identity="user@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 	private_key="/etc/cert/user.prv"
! 	private_key_passwd="password"
! 	priority=1
! }
! 
! # EAP-PEAP/MSCHAPv2 configuration for RADIUS servers that use the new peaplabel
! # (e.g., Radiator)
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=PEAP
! 	identity="user@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	phase1="peaplabel=1"
! 	phase2="auth=MSCHAPV2"
! 	priority=10
! }
! 
! # EAP-TTLS/EAP-MD5-Challenge configuration with anonymous identity for the
! # unencrypted use. Real identity is sent only within an encrypted TLS tunnel.
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	identity="user@example.com"
! 	anonymous_identity="anonymous@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	priority=2
! }
! 
! # EAP-TTLS/MSCHAPv2 configuration with anonymous identity for the unencrypted
! # use. Real identity is sent only within an encrypted TLS tunnel.
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	identity="user@example.com"
! 	anonymous_identity="anonymous@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	phase2="auth=MSCHAPV2"
! }
! 
! # WPA-EAP, EAP-TTLS with different CA certificate used for outer and inner
! # authentication.
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	# Phase1 / outer authentication
! 	anonymous_identity="anonymous@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	# Phase 2 / inner authentication
! 	phase2="autheap=TLS"
! 	ca_cert2="/etc/cert/ca2.pem"
! 	client_cert2="/etc/cer/user.pem"
! 	private_key2="/etc/cer/user.prv"
! 	private_key2_passwd="password"
! 	priority=2
! }
! 
! # Both WPA-PSK and WPA-EAP is accepted. Only CCMP is accepted as pairwise and
! # group cipher.
! network={
! 	ssid="example"
! 	bssid=00:11:22:33:44:55
! 	proto=WPA RSN
! 	key_mgmt=WPA-PSK WPA-EAP
! 	pairwise=CCMP
! 	group=CCMP
! 	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
! }
! 
! # Special characters in SSID, so use hex string. Default to WPA-PSK, WPA-EAP
! # and all valid ciphers.
! network={
! 	ssid=00010203
! 	psk=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
! }
! 
! 
! # EAP-SIM with a GSM SIM or USIM
! network={
! 	ssid="eap-sim-test"
! 	key_mgmt=WPA-EAP
! 	eap=SIM
! 	pin="1234"
! 	pcsc=""
! }
! 
! 
! # EAP-PSK
! network={
! 	ssid="eap-psk-test"
! 	key_mgmt=WPA-EAP
! 	eap=PSK
! 	identity="eap_psk_user"
! 	eappsk=06b4be19da289f475aa46a33cb793029
! 	nai="eap_psk_user@example.com"
! }
! 
! 
! # IEEE 802.1X/EAPOL with dynamically generated WEP keys (i.e., no WPA) using
! # EAP-TLS for authentication and key generation; require both unicast and
! # broadcast WEP keys.
! network={
! 	ssid="1x-test"
! 	key_mgmt=IEEE8021X
! 	eap=TLS
! 	identity="user@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 	private_key="/etc/cert/user.prv"
! 	private_key_passwd="password"
! 	eapol_flags=3
! }
! 
! 
! # LEAP with dynamic WEP keys
! network={
! 	ssid="leap-example"
! 	key_mgmt=IEEE8021X
! 	eap=LEAP
! 	identity="user"
! 	password="foobar"
! }
! 
! # EAP-FAST with WPA (WPA or WPA2)
! network={
! 	ssid="eap-fast-test"
! 	key_mgmt=WPA-EAP
! 	eap=FAST
! 	anonymous_identity="FAST-000102030405"
! 	identity="username"
! 	password="password"
! 	phase1="fast_provisioning=1"
! 	pac_file="/etc/wpa_supplicant.eap-fast-pac"
! }
! 
! network={
! 	ssid="eap-fast-test"
! 	key_mgmt=WPA-EAP
! 	eap=FAST
! 	anonymous_identity="FAST-000102030405"
! 	identity="username"
! 	password="password"
! 	phase1="fast_provisioning=1"
! 	pac_file="blob://eap-fast-pac"
! }
! 
! # Plaintext connection (no WPA, no IEEE 802.1X)
! network={
! 	ssid="plaintext-test"
! 	key_mgmt=NONE
! }
! 
! 
! # Shared WEP key connection (no WPA, no IEEE 802.1X)
! network={
! 	ssid="static-wep-test"
! 	key_mgmt=NONE
! 	wep_key0="abcde"
! 	wep_key1=0102030405
! 	wep_key2="1234567890123"
! 	wep_tx_keyidx=0
! 	priority=5
! }
! 
! 
! # Shared WEP key connection (no WPA, no IEEE 802.1X) using Shared Key
! # IEEE 802.11 authentication
! network={
! 	ssid="static-wep-test2"
! 	key_mgmt=NONE
! 	wep_key0="abcde"
! 	wep_key1=0102030405
! 	wep_key2="1234567890123"
! 	wep_tx_keyidx=0
! 	priority=5
! 	auth_alg=SHARED
! }
! 
! 
! # IBSS/ad-hoc network with WPA-None/TKIP.
! network={
! 	ssid="test adhoc"
! 	mode=1
! 	proto=WPA
! 	key_mgmt=WPA-NONE
! 	pairwise=NONE
! 	group=TKIP
! 	psk="secret passphrase"
! }
! 
! 
! # Catch all example that allows more or less all configuration modes
! network={
! 	ssid="example"
! 	scan_ssid=1
! 	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP WEP104 WEP40
! 	psk="very secret passphrase"
! 	eap=TTLS PEAP TLS
! 	identity="user@example.com"
! 	password="foobar"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 	private_key="/etc/cert/user.prv"
! 	private_key_passwd="password"
! 	phase1="peaplabel=0"
! }
! 
! # Example of EAP-TLS with smartcard (openssl engine)
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TLS
! 	proto=RSN
! 	pairwise=CCMP TKIP
! 	group=CCMP TKIP
! 	identity="user@example.com"
! 	ca_cert="/etc/cert/ca.pem"
! 	client_cert="/etc/cert/user.pem"
! 
! 	engine=1
! 
! 	# The engine configured here must be available. Look at
! 	# OpenSSL engine support in the global section.
! 	# The key available through the engine must be the private key
! 	# matching the client certificate configured above.
! 
! 	# use the opensc engine
! 	#engine_id="opensc"
! 	#key_id="45"
! 
! 	# use the pkcs11 engine
! 	engine_id="pkcs11"
! 	key_id="id_45"
! 
! 	# Optional PIN configuration; this can be left out and PIN will be
! 	# asked through the control interface
! 	pin="1234"
! }
! 
! # Example configuration showing how to use an inlined blob as a CA certificate
! # data instead of using external file
! network={
! 	ssid="example"
! 	key_mgmt=WPA-EAP
! 	eap=TTLS
! 	identity="user@example.com"
! 	anonymous_identity="anonymous@example.com"
! 	password="foobar"
! 	ca_cert="blob://exampleblob"
! 	priority=20
! }
! 
! blob-base64-exampleblob={
! SGVsbG8gV29ybGQhCg==
! }
! 
! 
! # Wildcard match for SSID (plaintext APs only). This example select any
! # open AP regardless of its SSID.
! network={
! 	key_mgmt=NONE
! }
Only in wpa_suppl: wpa_supplicant.d
diff -cr wpa_supplicant-0.5.7/wpa_supplicant.h wpa_suppl/wpa_supplicant.h
*** wpa_supplicant-0.5.7/wpa_supplicant.h	2009-08-16 14:25:01.003203000 +0300
--- wpa_suppl/wpa_supplicant.h	2007-11-07 16:18:03.000000000 +0200
***************
*** 123,128 ****
--- 123,137 ----
  	 */
  	EVENT_PMKID_CANDIDATE,
  
+ #ifdef CONFIG_EAP_WSC
+ 	/**
+ 	 * EVENT_WSC_PBC_OVERLAP - notfication of a PBC overlap
+ 	 *
+ 	 * This event is used to inform the WSC of the supplicant that more 
+ 	 * than on AP is in PBC mode 
+ 	 */
+ 	EVENT_WSC_PBC_OVERLAP,
+ #endif
  	/**
  	 * EVENT_STKSTART - Request STK handshake (MLME-STKSTART.request)
  	 *
diff -cr wpa_supplicant-0.5.7/wpa_supplicant_i.h wpa_suppl/wpa_supplicant_i.h
*** wpa_supplicant-0.5.7/wpa_supplicant_i.h	2009-08-16 14:25:02.000121000 +0300
--- wpa_suppl/wpa_supplicant_i.h	2007-11-07 16:18:04.000000000 +0200
***************
*** 691,694 ****
--- 691,706 ----
  	return -1;
  }
  
+ #ifdef CONFIG_EAP_WSC
+ static inline int wpa_drv_set_wsc_mode(struct wpa_supplicant *wpa_s,
+ 					  u32 WscMode,
+ 					  void* probeReqBuf,
+ 					  int probeReqBufLen)
+ {
+ 	if (wpa_s->driver->set_wsc_mode)
+ 		return wpa_s->driver->set_wsc_mode(wpa_s->drv_priv, WscMode, probeReqBuf, probeReqBufLen);
+ 	return -1;
+ }
+ #endif
+ 
  #endif /* WPA_SUPPLICANT_I_H */
Only in wpa_suppl: wpa_supplicant.o
Only in wpa_suppl: wsc_supplicant.c
Only in wpa_suppl: wsc_supplicant.d
Only in wpa_suppl: wsc_supplicant.h
Only in wpa_suppl: wsc_supplicant.o
Only in wpa_suppl: WscTypes.h
